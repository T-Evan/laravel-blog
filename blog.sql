-- MySQL dump 10.13  Distrib 5.7.21, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.21-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `blog`
--

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `blog` /*!40100 DEFAULT CHARACTER SET latin1 */;

USE `blog`;

--
-- Table structure for table `bjy_article_tags`
--

DROP TABLE IF EXISTS `bjy_article_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_article_tags` (
  `article_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '文章id',
  `tag_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '标签id',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_article_tags`
--

LOCK TABLES `bjy_article_tags` WRITE;
/*!40000 ALTER TABLE `bjy_article_tags` DISABLE KEYS */;
INSERT INTO `bjy_article_tags` VALUES (1,1,'2017-07-18 07:35:12','2016-07-18 07:35:12',NULL),(3,4,'2018-03-16 23:50:46','2018-03-16 23:50:46',NULL),(3,5,'2018-03-16 23:50:46','2018-03-16 23:50:46',NULL),(4,4,'2018-03-17 00:07:43','2018-03-17 00:07:43',NULL),(4,5,'2018-03-17 00:07:43','2018-03-17 00:07:43',NULL),(5,7,'2018-03-17 00:45:02','2018-03-17 00:45:02',NULL),(8,2,'2018-03-17 17:47:36','2018-03-17 17:47:36',NULL),(7,9,'2018-03-17 18:26:13','2018-03-17 18:26:13',NULL),(9,2,'2018-03-17 23:36:50','2018-03-17 23:36:50',NULL),(9,5,'2018-03-17 23:36:51','2018-03-17 23:36:51',NULL),(10,2,'2018-03-18 16:02:58','2018-03-18 16:02:58',NULL),(10,4,'2018-03-18 16:02:58','2018-03-18 16:02:58',NULL),(10,5,'2018-03-18 16:02:58','2018-03-18 16:02:58',NULL),(11,2,'2018-03-18 17:22:55','2018-03-18 17:22:55',NULL),(11,4,'2018-03-18 17:22:55','2018-03-18 17:22:55',NULL),(11,5,'2018-03-18 17:22:55','2018-03-18 17:22:55',NULL),(13,2,'2018-03-18 22:44:37','2018-03-18 22:44:37',NULL),(2,2,'2018-03-18 23:01:39','2018-03-18 23:01:39',NULL),(2,10,'2018-03-18 23:01:39','2018-03-18 23:01:39',NULL),(14,2,'2018-03-18 23:02:15','2018-03-18 23:02:15',NULL),(14,10,'2018-03-18 23:02:15','2018-03-18 23:02:15',NULL),(12,2,'2018-03-18 23:52:04','2018-03-18 23:52:04',NULL),(12,10,'2018-03-18 23:52:04','2018-03-18 23:52:04',NULL),(15,2,'2018-03-18 23:52:52','2018-03-18 23:52:52',NULL),(15,10,'2018-03-18 23:52:52','2018-03-18 23:52:52',NULL),(20,9,'2018-03-19 03:40:00','2018-03-19 03:40:00',NULL),(21,2,'2018-03-22 21:15:52','2018-03-22 21:15:52',NULL),(21,3,'2018-03-22 21:15:52','2018-03-22 21:15:52',NULL),(23,2,'2018-03-23 20:29:12','2018-03-23 20:29:12',NULL),(23,11,'2018-03-23 20:29:12','2018-03-23 20:29:12',NULL),(22,12,'2018-03-23 20:37:51','2018-03-23 20:37:51',NULL),(22,13,'2018-03-23 20:37:52','2018-03-23 20:37:52',NULL),(24,2,'2018-03-23 20:42:06','2018-03-23 20:42:06',NULL),(24,13,'2018-03-23 20:42:06','2018-03-23 20:42:06',NULL),(25,12,'2018-03-23 21:08:47','2018-03-23 21:08:47',NULL),(26,2,'2018-03-24 12:01:22','2018-03-24 12:01:22',NULL),(26,13,'2018-03-24 12:01:22','2018-03-24 12:01:22',NULL),(27,13,'2018-03-24 12:11:25','2018-03-24 12:11:25',NULL),(6,8,'2018-03-24 12:20:01','2018-03-24 12:20:01',NULL),(28,12,'2018-03-24 12:44:00','2018-03-24 12:44:00',NULL),(28,13,'2018-03-24 12:44:00','2018-03-24 12:44:00',NULL),(29,13,'2018-03-24 12:56:21','2018-03-24 12:56:21',NULL),(29,14,'2018-03-24 12:56:21','2018-03-24 12:56:21',NULL),(30,3,'2018-03-24 15:35:08','2018-03-24 15:35:08',NULL),(30,9,'2018-03-24 15:35:08','2018-03-24 15:35:08',NULL),(30,13,'2018-03-24 15:35:08','2018-03-24 15:35:08',NULL),(32,2,'2018-03-25 11:41:23','2018-03-25 11:41:23',NULL),(32,13,'2018-03-25 11:41:23','2018-03-25 11:41:23',NULL),(31,11,'2018-03-25 11:42:59','2018-03-25 11:42:59',NULL),(19,2,'2018-03-25 11:43:17','2018-03-25 11:43:17',NULL),(19,11,'2018-03-25 11:43:17','2018-03-25 11:43:17',NULL),(17,2,'2018-03-25 11:43:48','2018-03-25 11:43:48',NULL),(17,11,'2018-03-25 11:43:48','2018-03-25 11:43:48',NULL),(16,2,'2018-03-25 11:43:53','2018-03-25 11:43:53',NULL),(16,11,'2018-03-25 11:43:53','2018-03-25 11:43:53',NULL),(18,2,'2018-03-25 11:59:00','2018-03-25 11:59:00',NULL),(18,11,'2018-03-25 11:59:00','2018-03-25 11:59:00',NULL),(33,2,'2018-03-25 14:55:03','2018-03-25 14:55:03',NULL),(33,11,'2018-03-25 14:55:03','2018-03-25 14:55:03',NULL),(34,12,'2018-03-25 16:48:48','2018-03-25 16:48:48',NULL);
/*!40000 ALTER TABLE `bjy_article_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_articles`
--

DROP TABLE IF EXISTS `bjy_articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_articles` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '文章表主键',
  `category_id` tinyint(1) NOT NULL DEFAULT '0' COMMENT '分类id',
  `title` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '标题',
  `author` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '作者',
  `markdown` mediumtext COLLATE utf8_unicode_ci NOT NULL COMMENT 'markdown文章内容',
  `html` mediumtext COLLATE utf8_unicode_ci NOT NULL COMMENT 'markdown转的html页面',
  `description` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',
  `keywords` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '关键词',
  `cover` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '封面图',
  `is_top` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否置顶 1是 0否',
  `click` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '点击数',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_articles`
--

LOCK TABLES `bjy_articles` WRITE;
/*!40000 ALTER TABLE `bjy_articles` DISABLE KEYS */;
INSERT INTO `bjy_articles` VALUES (1,1,' 写给 thinkphp 开发者的 laravel 系列教程 (一) 序言','白俊遥','终于；终于；终于；\n开始正式写 laravel 系列了；\n本系列教程主要面向的是多少懂点 thinkphp3.X 的开发者们；\n我把我从tp3转到laravel的历程转成一篇篇的文章教程；\n愿这一系列的文章；\n能成为童鞋们踏入laravel的引路人；\n\n如果还没下定决定要使用laravel；\n那么我上来就是一个连接；\n[关于 thinkphp 和 laravel 框架的选择](http://baijunyao.com/article/109)\n不是别人说好我也跟着说好的；\n而是我实实在在的使用过后；\n不断的发现 laravel 的优雅；\n真心喜欢；才这么推荐的；\n\n另外学习使用 laravel 不同于 thinkphp；\nthinkphp 的问题；百度一下基本都能解决；\nlaravel 一定要有一把梯子来翻墙；\ngoogle是必不可少的；\n现在体会不到没关系；\n咱边学边感受；\n最近一段时间大批的vpn被关停了；\n这里我推荐一款依然坚挺的；\n我一直在用的；\n也比较喜欢的`免费`翻墙软件；\n[推荐开发工具系列之 -- 翻墙软件 lantern](http://baijunyao.com/article/107)\n\n最后给童鞋们推荐比较不错的国内的laravel网站；\n[Laravel China 社区](https://laravel-china.org/)\n[Laravel 学院](http://laravelacademy.org/)\n[laravel速查表](https://cs.laravel-china.org/)\n\n种一棵树最好的时间是十年前；其次是现在；\n让我们开始吧；\n![laravel](/uploads/article/5958ab4dd9db4.jpg \"laravel\")','<p>终于；终于；终于；<br>开始正式写 laravel 系列了；<br>本系列教程主要面向的是多少懂点 thinkphp3.X 的开发者们；<br>我把我从tp3转到laravel的历程转成一篇篇的文章教程；<br>愿这一系列的文章；<br>能成为童鞋们踏入laravel的引路人；</p><p>如果还没下定决定要使用laravel；<br>那么我上来就是一个连接；<br><a href=\"http://baijunyao.com/article/109\">关于 thinkphp 和 laravel 框架的选择</a><br>不是别人说好我也跟着说好的；<br>而是我实实在在的使用过后；<br>不断的发现 laravel 的优雅；<br>真心喜欢；才这么推荐的；</p><p>另外学习使用 laravel 不同于 thinkphp；<br>thinkphp 的问题；百度一下基本都能解决；<br>laravel 一定要有一把梯子来翻墙；<br>google是必不可少的；<br>现在体会不到没关系；<br>咱边学边感受；<br>最近一段时间大批的vpn被关停了；<br>这里我推荐一款依然坚挺的；<br>我一直在用的；<br>也比较喜欢的<code>免费</code>翻墙软件；<br><a href=\"http://baijunyao.com/article/107\">推荐开发工具系列之 -- 翻墙软件 lantern</a></p><p>最后给童鞋们推荐比较不错的国内的laravel网站；<br><a href=\"https://laravel-china.org/\">Laravel China 社区</a><br><a href=\"http://laravelacademy.org/\">Laravel 学院</a><br><a href=\"https://cs.laravel-china.org/\">laravel速查表</a></p><p>种一棵树最好的时间是十年前；其次是现在；<br>让我们开始吧；<br><img src=\"/uploads/article/5958ab4dd9db4.jpg\" alt=\"laravel\" title=\"laravel\"></p>','终于；终于；终于；\n开始正式写 laravel 系列了；\n本系列教程主要面向的是多少懂点 thinkphp3.X 的开发者们；\n我把我从tp3转到laravel的历程转成一篇篇的文章教程；\n愿这一系列的文章；\n能成为童鞋们踏入laravel的引路人；\n\n如果还没下定决定要使用laravel；\n那么我上来就是一个连接；\n\n不是别人说好我也跟着说好的；\n而是我实实在在的使用过后；...','laravel,thinkphp, 教程','/uploads/article/5958ab4dd9db4.jpg',1,666,'2017-07-16 07:35:12','2018-03-15 19:54:02','2018-03-15 19:54:02'),(2,2,'TCP三次握手与四次挥手过程','汤一碗','首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：\r\n\r\n![tcp建立链接](/uploads/article/20180315/5aaa61efbd426.png \"三次握手\")\r\n客户端将报文段中的SYN=1，并选择一个seq=x，(即该请求报文的序号为x)  将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN报文段不能携带数据，但是要消耗掉一个序号。\r\n服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个seq = y,且报文中确认号为x+1，序号为y   .此时服务器进入同步已接收状态（SYN-RCVD）\r\n\r\n\r\n客户端收到服务器的同步确认后，对服务器发送确认的确认。将ACK=1,确认号为y+1,而报文首部的序号为x+1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。\r\n\r\n\r\n服务器收到客户端的确认后，也进入已连接状态。\r\n以上即三次握手\r\n\r\n\r\n为何使用三次握手机制：\r\n假设如下异常情况：\r\n客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。\r\n\r\nTCP连接的释放（四次挥手）\r\n\r\n![四次挥手](/uploads/article/20180315/5aaa6229a23bb.png \"四次挥手\")\r\n连接的释放较连接的建立复杂。\r\n\r\n\r\n现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：\r\n\r\n\r\n1.客户端向服务器发送FIN报文：FIN=1,序号seq=上一个最后传输的字节序号+1=u，发送后，客户端进入FIN-WAIT-1状态。\r\n\r\n\r\n2.服务器接收到该报文后，发送一个确认报文：令ACK=1，确认序号ack = u+1,自己的报文序号seq=v，发送后，服务器进入CLOSE-WAIT状态。\r\n\r\n3.此时TCP连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。\r\n\r\n4.客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态。等待服务器发送连接释放报文。\r\n\r\n5.如果服务器已经没有要发送的数据，则释放TCP连接，向客户端发送报文：令FIN=1，ACK=1,确认号ack =u+1，自己的序号seq = w（w可能等于v也可能大于v），服务器进入LAST-ACK状态。\r\n\r\n6.客户端收到服务器的连接释放报文后，对该报文发出确认，令ACK=1,确认号ack=w+1，自己的序号seq=u+1，发送此报文后，等待2个msl时间后，进入CLOSED状态。\r\n\r\n7.服务器收到客户端的确认后，也进入CLOSED状态并撤销传输控制块。\r\n\r\n客户端状态变化：未连接----->SYN-SEND----->ESTABLISHED----->FIN-WAIT-1----->FIN-WAIT-2----->TIME-WAIT----->CLOSED\r\n\r\n服务器状态变化：未连接----->SYN-RCVD----->ESTABLISHED----->CLOSE-WAIT----->LAST-ACK----->CLOSED\r\n通俗描述3次握手就是\r\n\r\nA对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）\r\n\r\nB听到之后对A说：我的序号是y，期待你下一句序号是x+1的话（意思就是收到了序号为x的话，即ack=x+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）\r\n\r\nA听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）\r\n\r\nB听到A的确认之后，也进入ESTABLISHED状态。\r\n\r\n描述四次挥手就是：\r\n\r\n1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）\r\n\r\n2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）\r\n\r\n3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）\r\n\r\n4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)\r\n5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)\r\n6.B收到A的确认后，也进入CLOSED。\r\n\r\n\r\n\r\n\r\nQA：\r\n\r\n问题1： 为什么要三次握手？\r\n\r\n答：三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收机能正常。\r\n\r\n        第一次握手：Client什么都不能确认；Server确认了对方发送正常\r\n\r\n        第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常\r\n\r\n        第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常\r\n\r\n所以三次握手就能确认双发收发功能都正常，缺一不可。\r\n\r\n\r\n\r\n问题2：为什么要发送特定的数据包，随便发不行吗？\r\n\r\n答：三次握手的另外一个目的就是确认双方都支持TCP，告知对方用TCP传输。\r\n\r\n        第一次握手：Server 猜测Client可能要建立TCP请求，但不确定，因为也可能是Client乱发了一个数据包给自己\r\n\r\n        第二次握手：通过ack=J+1，Client知道Server是支持TCP的，且理解了自己要建立TCP连接的意图\r\n\r\n        第三次握手：通过ack=K+1，Server知道Client是支持TCP的，且确实是要建立TCP连接\r\n\r\n\r\n\r\n问题3：上图中的SYN和ACK是什么？\r\n\r\n答：SYN是标志位，SYN=1表示请求连接；\r\n\r\n        ACK其实就是ack后面加上的那个数，真正发送的时候不单独发ACK，只发ack，下面四次挥手的图同理\r\n\r\n问题4： 为什么要四次挥手？\r\n\r\n答：根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。（当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手）。\r\n\r\n        举个例子：A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答“我知道了”，但是B可能还会有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。\r\n\r\nPS：四次挥手的另一个原因是由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\r\n\r\n\r\n问题5：为什么双方要发送这样的数据包？\r\n\r\n答：和握手的情况类似，只是为了让对方知晓自己理解了对方的意图。\r\n\r\n\r\n参考自：http://blog.csdn.net/shuaicenglou3032/article/details/67634938','<p>首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：</p><p><img src=\"/uploads/article/20180315/5aaa61efbd426.png\" alt=\"tcp建立链接\" title=\"tcp建立链接\"><br>客户端将报文段中的SYN=1，并选择一个seq=x，(即该请求报文的序号为x)  将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYN-SEND）.SYN报文段不能携带数据，但是要消耗掉一个序号。<br>服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个seq = y,且报文中确认号为x+1，序号为y   .此时服务器进入同步已接收状态（SYN-RCVD）</p><p>客户端收到服务器的同步确认后，对服务器发送确认的确认。将ACK=1,确认号为y+1,而报文首部的序号为x+1，将该报文发出后，客户端进入已连接状态（ESTABLISHED）。</p><p>服务器收到客户端的确认后，也进入已连接状态。<br>以上即三次握手</p><p>为何使用三次握手机制：<br>假设如下异常情况：<br>客户端向服务器发送了第一条请求报文，但是该报文并未在网络中被丢弃，而是长时间阻滞在某处，而客户端收不到服务器确认，以为该报文丢失，于是重新发送该报文，这次的报文成功到达服务器，如果不使用三次握手，则服务器只需对该报文发出确认，就建立了一个连接。而在这个连接建立，并释放后，第一次发送的，阻滞在网络中的报文到达了服务器，服务器以为是客户端又重新发送了一个连接请求（实际上在客户端那里，该连接早已失效），就又向客户端发送一个确认，但客户端认为他没有发送该请求报文，因此不理睬服务器发送的确认，而服务器以为又建立了一个新的连接，于是一直等待A发来数据，造成了服务器资源的浪费，并且会产生安全隐患。因此，若使用三次握手机制，服务器发送了该确认后，收不到客户端的确认，也就知道并没有建立连接，因此不会将资源浪费在这种没有意义的等待上。</p><p>TCP连接的释放（四次挥手）</p><p><img src=\"/uploads/article/20180315/5aaa6229a23bb.png\" alt=\"四次挥手\" title=\"四次挥手\"><br>连接的释放较连接的建立复杂。</p><p>现假设客户端与服务器均处于连接建立状态，客户端主动断开连接：</p><p>1.客户端向服务器发送FIN报文：FIN=1,序号seq=上一个最后传输的字节序号+1=u，发送后，客户端进入FIN-WAIT-1状态。</p><p>2.服务器接收到该报文后，发送一个确认报文：令ACK=1，确认序号ack = u+1,自己的报文序号seq=v，发送后，服务器进入CLOSE-WAIT状态。</p><p>3.此时TCP连接进入连接半关闭状态，服务器可能还会向客户端发送一些数据。</p><p>4.客户端收到来自服务器的确认之后，进入FIN-WAIT-2状态。等待服务器发送连接释放报文。</p><p>5.如果服务器已经没有要发送的数据，则释放TCP连接，向客户端发送报文：令FIN=1，ACK=1,确认号ack =u+1，自己的序号seq = w（w可能等于v也可能大于v），服务器进入LAST-ACK状态。</p><p>6.客户端收到服务器的连接释放报文后，对该报文发出确认，令ACK=1,确认号ack=w+1，自己的序号seq=u+1，发送此报文后，等待2个msl时间后，进入CLOSED状态。</p><p>7.服务器收到客户端的确认后，也进入CLOSED状态并撤销传输控制块。</p><p>客户端状态变化：未连接-----&gt;SYN-SEND-----&gt;ESTABLISHED-----&gt;FIN-WAIT-1-----&gt;FIN-WAIT-2-----&gt;TIME-WAIT-----&gt;CLOSED</p><p>服务器状态变化：未连接-----&gt;SYN-RCVD-----&gt;ESTABLISHED-----&gt;CLOSE-WAIT-----&gt;LAST-ACK-----&gt;CLOSED<br>通俗描述3次握手就是</p><p>A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）</p><p>B听到之后对A说：我的序号是y，期待你下一句序号是x+1的话（意思就是收到了序号为x的话，即ack=x+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）</p><p>A听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）</p><p>B听到A的确认之后，也进入ESTABLISHED状态。</p><p>描述四次挥手就是：</p><p>1.A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）</p><p>2.B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）</p><p>3.A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）</p><p>4.B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)<br>5.A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)<br>6.B收到A的确认后，也进入CLOSED。</p><p>QA：</p><p>问题1： 为什么要三次握手？</p><p>答：三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收机能正常。</p><pre><code>    第一次握手：Client什么都不能确认；Server确认了对方发送正常\n\n    第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己接收正常，对方发送正常\n\n    第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了：自己发送、接收正常，对方发送接收正常\n</code></pre><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><p>问题2：为什么要发送特定的数据包，随便发不行吗？</p><p>答：三次握手的另外一个目的就是确认双方都支持TCP，告知对方用TCP传输。</p><pre><code>    第一次握手：Server 猜测Client可能要建立TCP请求，但不确定，因为也可能是Client乱发了一个数据包给自己\n\n    第二次握手：通过ack=J+1，Client知道Server是支持TCP的，且理解了自己要建立TCP连接的意图\n\n    第三次握手：通过ack=K+1，Server知道Client是支持TCP的，且确实是要建立TCP连接\n\n\n</code></pre><p>问题3：上图中的SYN和ACK是什么？</p><p>答：SYN是标志位，SYN=1表示请求连接；</p><pre><code>    ACK其实就是ack后面加上的那个数，真正发送的时候不单独发ACK，只发ack，下面四次挥手的图同理\n</code></pre><p>问题4： 为什么要四次挥手？</p><p>答：根本原因是，一方发送FIN只表示自己发完了所有要发的数据，但还允许对方继续把没发完的数据发过来。（当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手）。</p><pre><code>    举个例子：A和B打电话，通话即将结束后，A说“我没啥要说的了”，B回答“我知道了”，但是B可能还会有要说的话，A不能要求B跟着自己的节奏结束通话，于是B可能又巴拉巴拉说了一通，最后B说“我说完了”，A回答“知道了”，这样通话才算结束。\n</code></pre><p>PS：四次挥手的另一个原因是由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><p>问题5：为什么双方要发送这样的数据包？</p><p>答：和握手的情况类似，只是为了让对方知晓自己理解了对方的意图。</p><p>参考自：<a href=\"http://blog.csdn.net/shuaicenglou3032/article/details/67634938\">http://blog.csdn.net/shuaicenglou3032/article/details/67634938</a></p>','首先，客户端与服务器均处于未连接状态，并且是客户端主动向服务器请求建立连接：客户端将报文段中的SYN=1，并选择一个seq=x，(即该请求报文的序号为x)  将这个报文发送到服务器。此时，客户端进入同步已发送状态（SYNSEND）.SYN报文段不能携带数据，但是要消耗掉一个序号。服务器收到请求报文后，若同意建立连接，则回复报文中，SYN=1,ACK=1，并选择一个seq = y,且...','TCP','/uploads/article/20180315/5aaa61efbd426.png',0,8,'2018-03-15 19:59:07','2018-03-25 14:13:11',NULL),(3,2,'进程与线程','汤一碗','一、线程与进程的区别\r\n\r\n先简单说说线程与进程的概念：\r\n （1）进程是指一个内存中运行的应用程序，比如在Windows系统中，一个运行的exe就是一个进程。\r\n （2）线程是指进程中的一个执行流程。\r\n区别：\r\n一个程序至少有一个进程，而一个进程至少有一个线程。一个应用程序可以同时启动多个进程。例如对于IE浏览器程序，每打开一个IE浏览器窗口，就启动了一个新的进程。而线程则是指进程中的一个执行流程，一个进程可以有多个线程，每个线程分别执行不同的任务，当进程内的多个线程同时运行时，这种运行方式就被称为并发运行。\r\n另外，线程与进程还有一个非常重要的区别：每个进程在执行过程中都拥有独立的内存单元，而同一个进程中的多个线程则共享内存，从而极大地提高了程序的运行效率。\r\n\r\n二、对多线程并发的理解\r\n多线程并发只是表面和感觉上的并发，并不是实质上的并发。一个线程要运行，它必须占有CPU，而我们目前用的计算机大多都是单CPU的，所以一次最多只能有一个线程获取CPU并运行。\r\n多线程的实质是“最大限度地利用CPU资源”，当某一个线程的处理不需要占用CPU而只需要和I/O等资源打交道时，让其他线程有机会获得CPU资源。这有点类似于“统筹方法”，例如让你打扫房子和烧水，要在最短的时间内做好这两件事，你一定会想到先把水烧上，然后在等水烧开的空闲时间中去打扫房子，而不是先打扫好了再去烧水，也不是先烧好了再去打扫，这个例子里面，你是那个唯一的CPU，而烧水和打扫就是两个线程。\r\n虽然CPU只有一个，但是它在多个线程之间频繁切换，当切换的频率高到一定程度时，我们就感觉所有的线程在同时运行，于是感觉这多个线程是并发的。因此，并发并不是真的指多个线程同时运行，它仅仅只是形容一种现象。','<p>一、线程与进程的区别</p><p>先简单说说线程与进程的概念：<br> （1）进程是指一个内存中运行的应用程序，比如在Windows系统中，一个运行的exe就是一个进程。<br> （2）线程是指进程中的一个执行流程。<br>区别：<br>一个程序至少有一个进程，而一个进程至少有一个线程。一个应用程序可以同时启动多个进程。例如对于IE浏览器程序，每打开一个IE浏览器窗口，就启动了一个新的进程。而线程则是指进程中的一个执行流程，一个进程可以有多个线程，每个线程分别执行不同的任务，当进程内的多个线程同时运行时，这种运行方式就被称为并发运行。<br>另外，线程与进程还有一个非常重要的区别：每个进程在执行过程中都拥有独立的内存单元，而同一个进程中的多个线程则共享内存，从而极大地提高了程序的运行效率。</p><p>二、对多线程并发的理解<br>多线程并发只是表面和感觉上的并发，并不是实质上的并发。一个线程要运行，它必须占有CPU，而我们目前用的计算机大多都是单CPU的，所以一次最多只能有一个线程获取CPU并运行。<br>多线程的实质是“最大限度地利用CPU资源”，当某一个线程的处理不需要占用CPU而只需要和I/O等资源打交道时，让其他线程有机会获得CPU资源。这有点类似于“统筹方法”，例如让你打扫房子和烧水，要在最短的时间内做好这两件事，你一定会想到先把水烧上，然后在等水烧开的空闲时间中去打扫房子，而不是先打扫好了再去烧水，也不是先烧好了再去打扫，这个例子里面，你是那个唯一的CPU，而烧水和打扫就是两个线程。<br>虽然CPU只有一个，但是它在多个线程之间频繁切换，当切换的频率高到一定程度时，我们就感觉所有的线程在同时运行，于是感觉这多个线程是并发的。因此，并发并不是真的指多个线程同时运行，它仅仅只是形容一种现象。</p>','一、线程与进程的区别先简单说说线程与进程的概念： （1）进程是指一个内存中运行的应用程序，比如在Windows系统中，一个运行的exe就是一个进程。 （2）线程是指进程中的一个执行流程。区别：一个程序至少有一个进程，而一个进程至少有一个线程。一个应用程序可以同时启动多个进程。例如对于IE浏览器程序，每打开一个IE浏览器窗口，就启动了一个新的进程。而线程则是指进程中的一个执行...','进程，线程','uploads/article/default.jpg',0,7,'2018-03-15 20:21:26','2018-03-25 22:55:04',NULL),(4,2,'多线程同步的方法','汤一碗','线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量和信号量。\r\n条件变量需要和互斥锁同时使用，信号量实现前两者的功能。\r\n1）互斥锁（mutex）\r\n\r\n通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码。\r\n\r\n```c\r\nint pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutex_attr_t *mutexattr);\r\nint pthread_mutex_lock(pthread_mutex *mutex);\r\nint pthread_mutex_destroy(pthread_mutex *mutex);\r\nint pthread_mutex_unlock(pthread_mutex *\r\n```\r\n\r\n(1)先初始化锁init()或静态赋值\r\npthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIERattr_t有:\r\n```c\r\nPTHREAD_MUTEX_TIMED_NP:其余线程等待队列\r\nPTHREAD_MUTEX_RECURSIVE_NP:嵌套锁,允许线程多次加锁,不同线程,解锁后重新竞争\r\nPTHREAD_MUTEX_ERRORCHECK_NP:检错,与一同,线程请求已用锁,返回EDEADLK;\r\nPTHREAD_MUTEX_ADAPTIVE_NP:适应锁,解锁后重新竞争\r\n```\r\n\r\n(2)加锁,lock,trylock,lock阻塞等待锁,trylock立即返回EBUSY\r\n\r\n(3)解锁,unlock需满足是加锁状态,且由加锁线程解锁\r\n\r\n(4)清除锁,destroy(此时锁必需unlock,否则返回EBUSY,//Linux下互斥锁不占用内存资源\r\n\r\n示例代码\r\n\r\n```c\r\n#include <cstdio> \r\n\r\n#include <cstdlib> \r\n\r\n#include <unistd.h> \r\n\r\n#include <pthread.h> \r\n\r\n#include \"iostream\" \r\n\r\n   \r\n\r\nusing namespace std; \r\n\r\n   \r\n\r\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; \r\n\r\nint tmp; \r\n\r\n   \r\n\r\nvoid* thread(void *arg) \r\n\r\n{ \r\n\r\n    cout << \"thread id is \" << pthread_self() << endl; \r\n\r\n    pthread_mutex_lock(&mutex); \r\n\r\n    tmp = 12; \r\n\r\n    cout << \"Now a is \" << tmp << endl; \r\n\r\n    pthread_mutex_unlock(&mutex); \r\n\r\n    return NULL; \r\n\r\n} \r\n\r\n   \r\n\r\nint main() \r\n\r\n{ \r\n\r\n    pthread_t id; \r\n\r\n    cout << \"main thread id is \" << pthread_self() << endl; \r\n\r\n    tmp = 3; \r\n\r\n    cout << \"In main func tmp = \" << tmp << endl; \r\n\r\n    if (!pthread_create(&id, NULL, thread, NULL)) \r\n\r\n    { \r\n\r\n        cout << \"Create thread success!\" << endl; \r\n\r\n    } \r\n\r\n    else \r\n\r\n    { \r\n\r\n        cout << \"Create thread failed!\" << endl; \r\n\r\n    } \r\n\r\n    pthread_join(id, NULL); \r\n\r\n    pthread_mutex_destroy(&mutex); \r\n\r\n    return 0; \r\n\r\n}\r\n```\r\n\r\n编译： g++ -o thread testthread.cpp -lpthread\r\n\r\n说明：pthread库不是Linux系统默认的库，连接时需要使用静态库libpthread.a，所以在使用pthread_create()创建线程，以及调用pthread_atfork()函数建立fork处理程序时，需要链接该库。在编译中要加 -lpthread参数。\r\n\r\n \r\n\r\n2）条件变量（cond）\r\n\r\n利用线程间共享的全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。\r\n```c\r\nint pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);   \r\n\r\nint pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);\r\n\r\nint pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);\r\n\r\nint pthread_cond_destroy(pthread_cond_t *cond);\r\n\r\nint pthread_cond_signal(pthread_cond_t *cond);\r\n\r\nint pthread_cond_broadcast(pthread_cond_t *cond);  //解除所有线程的阻塞\r\n```\r\n(1)初始化.init()或者pthread_cond_t cond=PTHREAD_COND_INITIALIER（前者为动态初始化，后者为静态初始化）;属性置为NULL\r\n\r\n(2)等待条件成立.pthread_wait,pthread_timewait.wait()释放锁,并阻塞等待条件变量为真，timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)\r\n\r\n(3)激活条件变量:pthread_cond_signal,pthread_cond_broadcast(激活所有等待线程)\r\n\r\n(4)清除条件变量:destroy;无线程等待,否则返回EBUSY\r\n\r\n对于\r\n```c\r\nint pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\r\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);\r\n```\r\n一定要在mutex的锁定区域内使用。\r\n\r\n如果要正确的使用pthread_mutex_lock与pthread_mutex_unlock，请参考\r\n\r\npthread_cleanup_push和pthread_cleanup_pop宏，它能够在线程被cancel的时候正确的释放mutex！\r\n\r\n另外，posix1标准说，pthread_cond_signal与pthread_cond_broadcast无需考虑调用线程是否是mutex的拥有者，也就是说，可以在lock与unlock以外的区域调用。如果我们对调用行为不关心，那么请在lock区域之外调用吧。\r\n\r\n说明：\r\n\r\n  (1)pthread_cond_wait 自动解锁互斥量(如同执行了pthread_unlock_mutex)，并等待条件变量触发。这时线程挂起，不占用CPU时间，直到条件变量被触发（变量为ture）。在调用 pthread_cond_wait之前，应用程序必须加锁互斥量。pthread_cond_wait函数返回前，自动重新对互斥量加锁(如同执行了pthread_lock_mutex)。\r\n  (2)互斥量的解锁和在条件变量上挂起都是自动进行的。因此，在条件变量被触发前，如果所有的线程都要对互斥量加锁，这种机制可保证在线程加锁互斥量和进入等待条件变量期间，条件变量不被触发。条件变量要和互斥量相联结，以避免出现条件竞争——个线程预备等待一个条件变量，当它在真正进入等待之前，另一个线程恰好触发了该条件（条件满足信号有可能在测试条件和调用pthread_cond_wait函数（block）之间被发出，从而造成无限制的等待）。\r\n\r\n(3)pthread_cond_timedwait 和 pthread_cond_wait 一样，自动解锁互斥量及等待条件变量，但它还限定了等待时间。如果在abstime指定的时间内cond未触发，互斥量mutex被重新加锁，且pthread_cond_timedwait返回错误 ETIMEDOUT。abstime 参数指定一个绝对时间，时间原点与 time 和 gettimeofday相同：abstime = 0 表示 1970年1月1日00:00:00 GMT。\r\n\r\n(4)pthread_cond_destroy 销毁一个条件变量，释放它拥有的资源。进入 pthread_cond_destroy 之前，必须没有在该条件变量上等待的线程。\r\n\r\n(5)条件变量函数不是异步信号安全的，不应当在信号处理程序中进行调用。特别要注意，如果在信号处理程序中调用 pthread_cond_signal 或pthread_cond_boardcast 函数，可能导致调用线程死锁。\r\n\r\n示例程序1\r\n\r\n```c\r\n\r\n#include <stdio.h>\r\n#include <pthread.h>\r\n#include \"stdlib.h\"\r\n#include \"unistd.h\"\r\n\r\npthread_mutex_t mutex;\r\npthread_cond_t cond;\r\n\r\nvoid hander(void *arg)\r\n{\r\n    free(arg); \r\n    (void)pthread_mutex_unlock(&mutex);\r\n}\r\n\r\nvoid *thread1(void *arg)\r\n{\r\n     pthread_cleanup_push(hander, &mutex); \r\n     while(1) \r\n     { \r\n         printf(\"thread1 is running\\n\"); \r\n         pthread_mutex_lock(&mutex); \r\n         pthread_cond_wait(&cond,&mutex); \r\n         printf(\"thread1 applied the condition\\n\"); \r\n         pthread_mutex_unlock(&mutex); \r\n         sleep(4); \r\n     } \r\n     pthread_cleanup_pop(0); \r\n} \r\n\r\nvoid *thread2(void *arg)\r\n{ \r\n    while(1) \r\n    { \r\n        printf(\"thread2 is running\\n\"); \r\n        pthread_mutex_lock(&mutex); \r\n        pthread_cond_wait(&cond,&mutex); \r\n        printf(\"thread2 applied the condition\\n\"); \r\n        pthread_mutex_unlock(&mutex); \r\n        sleep(1); \r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n     pthread_t thid1,thid2; \r\n     printf(\"condition variable study!\\n\"); \r\n     pthread_mutex_init(&mutex,NULL); \r\n     pthread_cond_init(&cond,NULL); \r\n     pthread_create(&thid1,NULL,thread1,NULL); \r\n     pthread_create(&thid2,NULL,thread2,NULL); \r\n     sleep(1); \r\n     do \r\n     { \r\n         pthread_cond_signal(&cond); \r\n     }while(1); \r\n     sleep(20); \r\n     pthread_exit(0); \r\n     return 0;\r\n}\r\n```\r\n示例程序2：\r\n```c\r\n#include <pthread.h> \r\n#include <unistd.h> \r\n#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n\r\nstatic pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; \r\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER; \r\n\r\nstruct node \r\n{\r\n     int n_number; \r\n     struct node *n_next; \r\n} *head = NULL; \r\n\r\n/*[thread_func]*/ \r\nstatic void cleanup_handler(void *arg) \r\n{\r\n     printf(\"Cleanup handler of second thread./n\"); \r\n     free(arg); \r\n     (void)pthread_mutex_unlock(&mtx); \r\n} \r\n\r\nstatic void *thread_func(void *arg) \r\n{\r\n     struct node *p = NULL; \r\n     pthread_cleanup_push(cleanup_handler, p); \r\n     while (1) \r\n     { \r\n         //这个mutex主要是用来保证pthread_cond_wait的并发性\r\n         pthread_mutex_lock(&mtx); \r\n         while (head == NULL) \r\n         { \r\n         //这个while要特别说明一下，单个pthread_cond_wait功能很完善，为何\r\n         //这里要有一个while (head == NULL)呢？因为pthread_cond_wait里的线 \r\n         //程可能会被意外唤醒，如果这个时候head != NULL，则不是我们想要的情况。 \r\n         //这个时候，应该让线程继续进入pthread_cond_wait \r\n         // pthread_cond_wait会先解除之前的pthread_mutex_lock锁定的mtx， \r\n         //然后阻塞在等待对列里休眠，直到再次被唤醒（大多数情况下是等待的条件成立 \r\n         //而被唤醒，唤醒后，该进程会先锁定先pthread_mutex_lock(&mtx);，再读取资源 \r\n         //用这个流程是比较清楚的/*block-->unlock-->wait() return-->lock*/ \r\n         pthread_cond_wait(&cond, &mtx); \r\n         p = head; \r\n         head = head->n_next; \r\n         printf(\"Got %d from front of queue/n\", p->n_number);\r\n         free(p); \r\n          } \r\n          pthread_mutex_unlock(&mtx); //临界区数据操作完毕，释放互斥锁 \r\n     } \r\n     pthread_cleanup_pop(0); \r\n     return 0; \r\n} \r\n\r\nint main(void) \r\n{\r\n     pthread_t tid; \r\n     int i; \r\n     struct node *p; \r\n     //子线程会一直等待资源，类似生产者和消费者，但是这里的消费者可以是多个消费者，而 \r\n     //不仅仅支持普通的单个消费者，这个模型虽然简单，但是很强大\r\n     pthread_create(&tid, NULL, thread_func, NULL); \r\n     sleep(1); \r\n     for (i = 0; i < 10; i++) \r\n     { \r\n         p = (struct node*)malloc(sizeof(struct node)); \r\n         p->n_number = i; \r\n         pthread_mutex_lock(&mtx); //需要操作head这个临界资源，先加锁， \r\n         p->n_next = head; \r\n         head = p; \r\n         pthread_cond_signal(&cond); \r\n         pthread_mutex_unlock(&mtx); //解锁 \r\n         sleep(1); \r\n     } \r\n     printf(\"thread 1 wanna end the line.So cancel thread 2./n\"); \r\n     \r\n     //关于pthread_cancel，有一点额外的说明，它是从外部终止子线程，子线程会在最近的取消点，退出 \r\n     //线程，而在我们的代码里，最近的取消点肯定就是pthread_cond_wait()了。 \r\n     pthread_cancel(tid); \r\n     pthread_join(tid, NULL); \r\n     printf(\"All done -- exiting/n\"); \r\n     return 0; \r\n}\r\n```\r\n3）信号量\r\n\r\n   如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。\r\n\r\n   信号量函数的名字都以\"sem_\"打头。线程使用的基本信号量函数有四个。\r\n```c\r\n#include\r\nint sem_init (sem_t *sem , int pshared, unsigned int value);\r\n```\r\n   这是对由sem指定的信号量进行初始化，设置好它的共享选项（linux 只支持为0，即表示它是当前进程的局部信号量），然后给它一个初始值VALUE。\r\n\r\n两个原子操作函数：\r\n```c\r\nint sem_wait(sem_t *sem);\r\nint sem_post(sem_t *sem);\r\n```\r\n   这两个函数都要用一个由sem_init调用初始化的信号量对象的指针做参数。\r\n\r\nsem_post：给信号量的值加1；\r\n\r\nsem_wait:给信号量减1；对一个值为0的信号量调用sem_wait,这个函数将会等待直到有其它线程使它不再是0为止。\r\n\r\nint sem_destroy(sem_t *sem);\r\n\r\n   这个函数的作用是再我们用完信号量后都它进行清理。归还自己占有的一切资源。\r\n\r\n \r\n\r\n示例代码：\r\n\r\n```c\r\n#include <stdlib.h> \r\n#include <stdio.h> \r\n#include <unistd.h> \r\n#include <pthread.h> \r\n#include <semaphore.h> \r\n#include <errno.h> \r\n    \r\n#define return_if_fail(p) if((p) == 0){printf (\"[%s]:func error!/n\", __func__);return;} \r\n    \r\ntypedef struct _PrivInfo \r\n{ \r\n  sem_t s1; \r\n  sem_t s2; \r\n  time_t end_time; \r\n}PrivInfo; \r\n    \r\nstatic void info_init (PrivInfo* thiz); \r\nstatic void info_destroy (PrivInfo* thiz); \r\nstatic void* pthread_func_1 (PrivInfo* thiz); \r\nstatic void* pthread_func_2 (PrivInfo* thiz); \r\n    \r\nint main (int argc, char** argv) \r\n{ \r\n  pthread_t pt_1 = 0; \r\n  pthread_t pt_2 = 0; \r\n  int ret = 0; \r\n  PrivInfo* thiz = NULL; \r\n      \r\n  thiz = (PrivInfo* )malloc (sizeof (PrivInfo)); \r\n  if (thiz == NULL) \r\n  { \r\n    printf (\"[%s]: Failed to malloc priv./n\"); \r\n    return -1; \r\n  } \r\n    \r\n  info_init (thiz); \r\n    \r\n  ret = pthread_create (&pt_1, NULL, (void*)pthread_func_1, thiz); \r\n  if (ret != 0) \r\n  { \r\n    perror (\"pthread_1_create:\"); \r\n  } \r\n    \r\n  ret = pthread_create (&pt_2, NULL, (void*)pthread_func_2, thiz); \r\n  if (ret != 0) \r\n  { \r\n     perror (\"pthread_2_create:\"); \r\n  } \r\n    \r\n  pthread_join (pt_1, NULL); \r\n  pthread_join (pt_2, NULL); \r\n    \r\n  info_destroy (thiz); \r\n      \r\n  return 0; \r\n} \r\n    \r\nstatic void info_init (PrivInfo* thiz) \r\n{ \r\n  return_if_fail (thiz != NULL); \r\n    \r\n  thiz->end_time = time(NULL) + 10; \r\n      \r\n  sem_init (&thiz->s1, 0, 1); \r\n  sem_init (&thiz->s2, 0, 0); \r\n    \r\n  return; \r\n} \r\n    \r\nstatic void info_destroy (PrivInfo* thiz) \r\n{ \r\n  return_if_fail (thiz != NULL); \r\n    \r\n  sem_destroy (&thiz->s1); \r\n  sem_destroy (&thiz->s2); \r\n    \r\n  free (thiz); \r\n  thiz = NULL; \r\n    \r\n  return; \r\n} \r\n    \r\nstatic void* pthread_func_1 (PrivInfo* thiz) \r\n{ \r\n  return_if_fail (thiz != NULL); \r\n    \r\n  while (time(NULL) < thiz->end_time) \r\n  { \r\n    sem_wait (&thiz->s2); \r\n    printf (\"pthread1: pthread1 get the lock./n\"); \r\n    \r\n    sem_post (&thiz->s1); \r\n    printf (\"pthread1: pthread1 unlock/n\"); \r\n    \r\n    sleep (1); \r\n  } \r\n    \r\n  return; \r\n} \r\n    \r\nstatic void* pthread_func_2 (PrivInfo* thiz) \r\n{ \r\n  return_if_fail (thiz != NULL); \r\n    \r\n  while (time (NULL) < thiz->end_time) \r\n  { \r\n    sem_wait (&thiz->s1); \r\n    printf (\"pthread2: pthread2 get the unlock./n\"); \r\n    \r\n    sem_post (&thiz->s2); \r\n    printf (\"pthread2: pthread2 unlock./n\"); \r\n    \r\n    sleep (1); \r\n  } \r\n    \r\n  return; \r\n}\r\n```\r\n通过执行结果后，可以看出，会先执行线程二的函数，然后再执行线程一的函数。它们两就实现了同步。在上大学的时候，虽然对这些概念知道，可都没有实践过，所以有时候时间一久就会模糊甚至忘记，到了工作如果还保持这么一种状态，那就太可怕了。虽然现在外面的技术在不断的变化更新，可是不管怎么变，其核心技术还是依旧的，所以我们必须要打好自己的基础，再学习其他新的知识，那时候再学新的知识也会觉得比较简单的。信号量代码摘自http://blog.csdn.net/wtz1985/article/details/3835781\r\n\r\n参考：\r\n\r\n【1】 http://www.cnblogs.com/feisky/archive/2009/11/12/1601824.html\r\n\r\n【2】 http://www.cnblogs.com/mydomain/archive/2011/07/10/2102147.html\r\n\r\n【3】 线程函数介绍\r\n\r\nhttp://www.unix.org/version2/whatsnew/threadsref.html\r\n\r\n【4】 http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html\r\n\r\n【5】 线程常用函数简介\r\n\r\nhttp://www.rosoo.net/a/201004/8954.html\r\n\r\n【6】 条件变量\r\n\r\nhttp://blog.csdn.net/hiflower/article/details/2195350\r\n\r\n【7】条件变量函数说明\r\n\r\nhttp://blog.csdn.net/hairetz/article/details/4535920\r\n\r\n \r\n\r\n本文来自博文：\r\n\r\nhttp://www.cnblogs.com/mydomain/archive/2011/08/14/2138455.html','<p>线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量和信号量。<br>条件变量需要和互斥锁同时使用，信号量实现前两者的功能。<br>1）互斥锁（mutex）</p><p>通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码。</p><pre><code class=\"lang-c\">int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutex_attr_t *mutexattr);\nint pthread_mutex_lock(pthread_mutex *mutex);\nint pthread_mutex_destroy(pthread_mutex *mutex);\nint pthread_mutex_unlock(pthread_mutex *</code></pre><p>(1)先初始化锁init()或静态赋值<br>pthread_mutex_t mutex=PTHREAD_MUTEX_INITIALIERattr_t有:</p><pre><code class=\"lang-c\">PTHREAD_MUTEX_TIMED_NP:其余线程等待队列\nPTHREAD_MUTEX_RECURSIVE_NP:嵌套锁,允许线程多次加锁,不同线程,解锁后重新竞争\nPTHREAD_MUTEX_ERRORCHECK_NP:检错,与一同,线程请求已用锁,返回EDEADLK;\nPTHREAD_MUTEX_ADAPTIVE_NP:适应锁,解锁后重新竞争</code></pre><p>(2)加锁,lock,trylock,lock阻塞等待锁,trylock立即返回EBUSY</p><p>(3)解锁,unlock需满足是加锁状态,且由加锁线程解锁</p><p>(4)清除锁,destroy(此时锁必需unlock,否则返回EBUSY,//Linux下互斥锁不占用内存资源</p><p>示例代码</p><pre><code class=\"lang-c\">#include &lt;cstdio&gt; \n\n#include &lt;cstdlib&gt; \n\n#include &lt;unistd.h&gt; \n\n#include &lt;pthread.h&gt; \n\n#include &quot;iostream&quot; \n\n   \n\nusing namespace std; \n\n   \n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; \n\nint tmp; \n\n   \n\nvoid* thread(void *arg) \n\n{ \n\n    cout &lt;&lt; &quot;thread id is &quot; &lt;&lt; pthread_self() &lt;&lt; endl; \n\n    pthread_mutex_lock(&amp;mutex); \n\n    tmp = 12; \n\n    cout &lt;&lt; &quot;Now a is &quot; &lt;&lt; tmp &lt;&lt; endl; \n\n    pthread_mutex_unlock(&amp;mutex); \n\n    return NULL; \n\n} \n\n   \n\nint main() \n\n{ \n\n    pthread_t id; \n\n    cout &lt;&lt; &quot;main thread id is &quot; &lt;&lt; pthread_self() &lt;&lt; endl; \n\n    tmp = 3; \n\n    cout &lt;&lt; &quot;In main func tmp = &quot; &lt;&lt; tmp &lt;&lt; endl; \n\n    if (!pthread_create(&amp;id, NULL, thread, NULL)) \n\n    { \n\n        cout &lt;&lt; &quot;Create thread success!&quot; &lt;&lt; endl; \n\n    } \n\n    else \n\n    { \n\n        cout &lt;&lt; &quot;Create thread failed!&quot; &lt;&lt; endl; \n\n    } \n\n    pthread_join(id, NULL); \n\n    pthread_mutex_destroy(&amp;mutex); \n\n    return 0; \n\n}</code></pre><p>编译： g++ -o thread testthread.cpp -lpthread</p><p>说明：pthread库不是Linux系统默认的库，连接时需要使用静态库libpthread.a，所以在使用pthread_create()创建线程，以及调用pthread_atfork()函数建立fork处理程序时，需要链接该库。在编译中要加 -lpthread参数。</p><p>2）条件变量（cond）</p><p>利用线程间共享的全局变量进行同步的一种机制。条件变量上的基本操作有：触发条件(当条件变为 true 时)；等待条件，挂起线程直到其他线程触发条件。</p><pre><code class=\"lang-c\">int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);   \n\nint pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);\n\nint pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);\n\nint pthread_cond_destroy(pthread_cond_t *cond);\n\nint pthread_cond_signal(pthread_cond_t *cond);\n\nint pthread_cond_broadcast(pthread_cond_t *cond);  //解除所有线程的阻塞</code></pre><p>(1)初始化.init()或者pthread_cond_t cond=PTHREAD_COND_INITIALIER（前者为动态初始化，后者为静态初始化）;属性置为NULL</p><p>(2)等待条件成立.pthread_wait,pthread_timewait.wait()释放锁,并阻塞等待条件变量为真，timewait()设置等待时间,仍未signal,返回ETIMEOUT(加锁保证只有一个线程wait)</p><p>(3)激活条件变量:pthread_cond_signal,pthread_cond_broadcast(激活所有等待线程)</p><p>(4)清除条件变量:destroy;无线程等待,否则返回EBUSY</p><p>对于</p><pre><code class=\"lang-c\">int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\nint pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);</code></pre><p>一定要在mutex的锁定区域内使用。</p><p>如果要正确的使用pthread_mutex_lock与pthread_mutex_unlock，请参考</p><p>pthread_cleanup_push和pthread_cleanup_pop宏，它能够在线程被cancel的时候正确的释放mutex！</p><p>另外，posix1标准说，pthread_cond_signal与pthread_cond_broadcast无需考虑调用线程是否是mutex的拥有者，也就是说，可以在lock与unlock以外的区域调用。如果我们对调用行为不关心，那么请在lock区域之外调用吧。</p><p>说明：</p><p>(1)pthread_cond_wait 自动解锁互斥量(如同执行了pthread_unlock_mutex)，并等待条件变量触发。这时线程挂起，不占用CPU时间，直到条件变量被触发（变量为ture）。在调用 pthread_cond_wait之前，应用程序必须加锁互斥量。pthread_cond_wait函数返回前，自动重新对互斥量加锁(如同执行了pthread_lock_mutex)。<br>  (2)互斥量的解锁和在条件变量上挂起都是自动进行的。因此，在条件变量被触发前，如果所有的线程都要对互斥量加锁，这种机制可保证在线程加锁互斥量和进入等待条件变量期间，条件变量不被触发。条件变量要和互斥量相联结，以避免出现条件竞争——个线程预备等待一个条件变量，当它在真正进入等待之前，另一个线程恰好触发了该条件（条件满足信号有可能在测试条件和调用pthread_cond_wait函数（block）之间被发出，从而造成无限制的等待）。</p><p>(3)pthread_cond_timedwait 和 pthread_cond_wait 一样，自动解锁互斥量及等待条件变量，但它还限定了等待时间。如果在abstime指定的时间内cond未触发，互斥量mutex被重新加锁，且pthread_cond_timedwait返回错误 ETIMEDOUT。abstime 参数指定一个绝对时间，时间原点与 time 和 gettimeofday相同：abstime = 0 表示 1970年1月1日00:00:00 GMT。</p><p>(4)pthread_cond_destroy 销毁一个条件变量，释放它拥有的资源。进入 pthread_cond_destroy 之前，必须没有在该条件变量上等待的线程。</p><p>(5)条件变量函数不是异步信号安全的，不应当在信号处理程序中进行调用。特别要注意，如果在信号处理程序中调用 pthread_cond_signal 或pthread_cond_boardcast 函数，可能导致调用线程死锁。</p><p>示例程序1</p><pre><code class=\"lang-c\">\n#include &lt;stdio.h&gt;\n#include &lt;pthread.h&gt;\n#include &quot;stdlib.h&quot;\n#include &quot;unistd.h&quot;\n\npthread_mutex_t mutex;\npthread_cond_t cond;\n\nvoid hander(void *arg)\n{\n    free(arg); \n    (void)pthread_mutex_unlock(&amp;mutex);\n}\n\nvoid *thread1(void *arg)\n{\n     pthread_cleanup_push(hander, &amp;mutex); \n     while(1) \n     { \n         printf(&quot;thread1 is running\\n&quot;); \n         pthread_mutex_lock(&amp;mutex); \n         pthread_cond_wait(&amp;cond,&amp;mutex); \n         printf(&quot;thread1 applied the condition\\n&quot;); \n         pthread_mutex_unlock(&amp;mutex); \n         sleep(4); \n     } \n     pthread_cleanup_pop(0); \n} \n\nvoid *thread2(void *arg)\n{ \n    while(1) \n    { \n        printf(&quot;thread2 is running\\n&quot;); \n        pthread_mutex_lock(&amp;mutex); \n        pthread_cond_wait(&amp;cond,&amp;mutex); \n        printf(&quot;thread2 applied the condition\\n&quot;); \n        pthread_mutex_unlock(&amp;mutex); \n        sleep(1); \n    }\n}\n\nint main()\n{\n     pthread_t thid1,thid2; \n     printf(&quot;condition variable study!\\n&quot;); \n     pthread_mutex_init(&amp;mutex,NULL); \n     pthread_cond_init(&amp;cond,NULL); \n     pthread_create(&amp;thid1,NULL,thread1,NULL); \n     pthread_create(&amp;thid2,NULL,thread2,NULL); \n     sleep(1); \n     do \n     { \n         pthread_cond_signal(&amp;cond); \n     }while(1); \n     sleep(20); \n     pthread_exit(0); \n     return 0;\n}</code></pre><p>示例程序2：</p><pre><code class=\"lang-c\">#include &lt;pthread.h&gt; \n#include &lt;unistd.h&gt; \n#include &quot;stdio.h&quot;\n#include &quot;stdlib.h&quot;\n\nstatic pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; \nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER; \n\nstruct node \n{\n     int n_number; \n     struct node *n_next; \n} *head = NULL; \n\n/*[thread_func]*/ \nstatic void cleanup_handler(void *arg) \n{\n     printf(&quot;Cleanup handler of second thread./n&quot;); \n     free(arg); \n     (void)pthread_mutex_unlock(&amp;mtx); \n} \n\nstatic void *thread_func(void *arg) \n{\n     struct node *p = NULL; \n     pthread_cleanup_push(cleanup_handler, p); \n     while (1) \n     { \n         //这个mutex主要是用来保证pthread_cond_wait的并发性\n         pthread_mutex_lock(&amp;mtx); \n         while (head == NULL) \n         { \n         //这个while要特别说明一下，单个pthread_cond_wait功能很完善，为何\n         //这里要有一个while (head == NULL)呢？因为pthread_cond_wait里的线 \n         //程可能会被意外唤醒，如果这个时候head != NULL，则不是我们想要的情况。 \n         //这个时候，应该让线程继续进入pthread_cond_wait \n         // pthread_cond_wait会先解除之前的pthread_mutex_lock锁定的mtx， \n         //然后阻塞在等待对列里休眠，直到再次被唤醒（大多数情况下是等待的条件成立 \n         //而被唤醒，唤醒后，该进程会先锁定先pthread_mutex_lock(&amp;mtx);，再读取资源 \n         //用这个流程是比较清楚的/*block--&gt;unlock--&gt;wait() return--&gt;lock*/ \n         pthread_cond_wait(&amp;cond, &amp;mtx); \n         p = head; \n         head = head-&gt;n_next; \n         printf(&quot;Got %d from front of queue/n&quot;, p-&gt;n_number);\n         free(p); \n          } \n          pthread_mutex_unlock(&amp;mtx); //临界区数据操作完毕，释放互斥锁 \n     } \n     pthread_cleanup_pop(0); \n     return 0; \n} \n\nint main(void) \n{\n     pthread_t tid; \n     int i; \n     struct node *p; \n     //子线程会一直等待资源，类似生产者和消费者，但是这里的消费者可以是多个消费者，而 \n     //不仅仅支持普通的单个消费者，这个模型虽然简单，但是很强大\n     pthread_create(&amp;tid, NULL, thread_func, NULL); \n     sleep(1); \n     for (i = 0; i &lt; 10; i++) \n     { \n         p = (struct node*)malloc(sizeof(struct node)); \n         p-&gt;n_number = i; \n         pthread_mutex_lock(&amp;mtx); //需要操作head这个临界资源，先加锁， \n         p-&gt;n_next = head; \n         head = p; \n         pthread_cond_signal(&amp;cond); \n         pthread_mutex_unlock(&amp;mtx); //解锁 \n         sleep(1); \n     } \n     printf(&quot;thread 1 wanna end the line.So cancel thread 2./n&quot;); \n     \n     //关于pthread_cancel，有一点额外的说明，它是从外部终止子线程，子线程会在最近的取消点，退出 \n     //线程，而在我们的代码里，最近的取消点肯定就是pthread_cond_wait()了。 \n     pthread_cancel(tid); \n     pthread_join(tid, NULL); \n     printf(&quot;All done -- exiting/n&quot;); \n     return 0; \n}</code></pre><p>3）信号量</p><p>如同进程一样，线程也可以通过信号量来实现通信，虽然是轻量级的。</p><p>信号量函数的名字都以\"sem_\"打头。线程使用的基本信号量函数有四个。</p><pre><code class=\"lang-c\">#include\nint sem_init (sem_t *sem , int pshared, unsigned int value);</code></pre><p>这是对由sem指定的信号量进行初始化，设置好它的共享选项（linux 只支持为0，即表示它是当前进程的局部信号量），然后给它一个初始值VALUE。</p><p>两个原子操作函数：</p><pre><code class=\"lang-c\">int sem_wait(sem_t *sem);\nint sem_post(sem_t *sem);</code></pre><p>这两个函数都要用一个由sem_init调用初始化的信号量对象的指针做参数。</p><p>sem_post：给信号量的值加1；</p><p>sem_wait:给信号量减1；对一个值为0的信号量调用sem_wait,这个函数将会等待直到有其它线程使它不再是0为止。</p><p>int sem_destroy(sem_t *sem);</p><p>这个函数的作用是再我们用完信号量后都它进行清理。归还自己占有的一切资源。</p><p>示例代码：</p><pre><code class=\"lang-c\">#include &lt;stdlib.h&gt; \n#include &lt;stdio.h&gt; \n#include &lt;unistd.h&gt; \n#include &lt;pthread.h&gt; \n#include &lt;semaphore.h&gt; \n#include &lt;errno.h&gt; \n    \n#define return_if_fail(p) if((p) == 0){printf (&quot;[%s]:func error!/n&quot;, __func__);return;} \n    \ntypedef struct _PrivInfo \n{ \n  sem_t s1; \n  sem_t s2; \n  time_t end_time; \n}PrivInfo; \n    \nstatic void info_init (PrivInfo* thiz); \nstatic void info_destroy (PrivInfo* thiz); \nstatic void* pthread_func_1 (PrivInfo* thiz); \nstatic void* pthread_func_2 (PrivInfo* thiz); \n    \nint main (int argc, char** argv) \n{ \n  pthread_t pt_1 = 0; \n  pthread_t pt_2 = 0; \n  int ret = 0; \n  PrivInfo* thiz = NULL; \n      \n  thiz = (PrivInfo* )malloc (sizeof (PrivInfo)); \n  if (thiz == NULL) \n  { \n    printf (&quot;[%s]: Failed to malloc priv./n&quot;); \n    return -1; \n  } \n    \n  info_init (thiz); \n    \n  ret = pthread_create (&amp;pt_1, NULL, (void*)pthread_func_1, thiz); \n  if (ret != 0) \n  { \n    perror (&quot;pthread_1_create:&quot;); \n  } \n    \n  ret = pthread_create (&amp;pt_2, NULL, (void*)pthread_func_2, thiz); \n  if (ret != 0) \n  { \n     perror (&quot;pthread_2_create:&quot;); \n  } \n    \n  pthread_join (pt_1, NULL); \n  pthread_join (pt_2, NULL); \n    \n  info_destroy (thiz); \n      \n  return 0; \n} \n    \nstatic void info_init (PrivInfo* thiz) \n{ \n  return_if_fail (thiz != NULL); \n    \n  thiz-&gt;end_time = time(NULL) + 10; \n      \n  sem_init (&amp;thiz-&gt;s1, 0, 1); \n  sem_init (&amp;thiz-&gt;s2, 0, 0); \n    \n  return; \n} \n    \nstatic void info_destroy (PrivInfo* thiz) \n{ \n  return_if_fail (thiz != NULL); \n    \n  sem_destroy (&amp;thiz-&gt;s1); \n  sem_destroy (&amp;thiz-&gt;s2); \n    \n  free (thiz); \n  thiz = NULL; \n    \n  return; \n} \n    \nstatic void* pthread_func_1 (PrivInfo* thiz) \n{ \n  return_if_fail (thiz != NULL); \n    \n  while (time(NULL) &lt; thiz-&gt;end_time) \n  { \n    sem_wait (&amp;thiz-&gt;s2); \n    printf (&quot;pthread1: pthread1 get the lock./n&quot;); \n    \n    sem_post (&amp;thiz-&gt;s1); \n    printf (&quot;pthread1: pthread1 unlock/n&quot;); \n    \n    sleep (1); \n  } \n    \n  return; \n} \n    \nstatic void* pthread_func_2 (PrivInfo* thiz) \n{ \n  return_if_fail (thiz != NULL); \n    \n  while (time (NULL) &lt; thiz-&gt;end_time) \n  { \n    sem_wait (&amp;thiz-&gt;s1); \n    printf (&quot;pthread2: pthread2 get the unlock./n&quot;); \n    \n    sem_post (&amp;thiz-&gt;s2); \n    printf (&quot;pthread2: pthread2 unlock./n&quot;); \n    \n    sleep (1); \n  } \n    \n  return; \n}</code></pre><p>通过执行结果后，可以看出，会先执行线程二的函数，然后再执行线程一的函数。它们两就实现了同步。在上大学的时候，虽然对这些概念知道，可都没有实践过，所以有时候时间一久就会模糊甚至忘记，到了工作如果还保持这么一种状态，那就太可怕了。虽然现在外面的技术在不断的变化更新，可是不管怎么变，其核心技术还是依旧的，所以我们必须要打好自己的基础，再学习其他新的知识，那时候再学新的知识也会觉得比较简单的。信号量代码摘自<a href=\"http://blog.csdn.net/wtz1985/article/details/3835781\">http://blog.csdn.net/wtz1985/article/details/3835781</a></p><p>参考：</p><p>【1】 <a href=\"http://www.cnblogs.com/feisky/archive/2009/11/12/1601824.html\">http://www.cnblogs.com/feisky/archive/2009/11/12/1601824.html</a></p><p>【2】 <a href=\"http://www.cnblogs.com/mydomain/archive/2011/07/10/2102147.html\">http://www.cnblogs.com/mydomain/archive/2011/07/10/2102147.html</a></p><p>【3】 线程函数介绍</p><p><a href=\"http://www.unix.org/version2/whatsnew/threadsref.html\">http://www.unix.org/version2/whatsnew/threadsref.html</a></p><p>【4】 <a href=\"http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html\">http://www.yolinux.com/TUTORIALS/LinuxTutorialPosixThreads.html</a></p><p>【5】 线程常用函数简介</p><p><a href=\"http://www.rosoo.net/a/201004/8954.html\">http://www.rosoo.net/a/201004/8954.html</a></p><p>【6】 条件变量</p><p><a href=\"http://blog.csdn.net/hiflower/article/details/2195350\">http://blog.csdn.net/hiflower/article/details/2195350</a></p><p>【7】条件变量函数说明</p><p><a href=\"http://blog.csdn.net/hairetz/article/details/4535920\">http://blog.csdn.net/hairetz/article/details/4535920</a></p><p>本文来自博文：</p><p><a href=\"http://www.cnblogs.com/mydomain/archive/2011/08/14/2138455.html\">http://www.cnblogs.com/mydomain/archive/2011/08/14/2138455.html</a></p>','线程的最大特点是资源的共享性，但资源共享中的同步问题是多线程编程的难点。linux下提供了多种方式来处理线程同步，最常用的是互斥锁、条件变量和信号量。1）互斥锁（mutex）通过锁机制实现线程间的同步。同一时刻只允许一个线程执行一个关键部分的代码。```cint pthread_mutex_init(pthread_mutex_t mutex,const pthread_m...','多线程同步','uploads/article/default.jpg',0,4,'2018-03-17 00:00:15','2018-03-20 20:08:43',NULL),(5,2,'如何测试一个登陆界面','汤一碗','当我们写一个登陆界面，为使其更好的工作，也为了有更好的用户体验，我们需要对登陆界面进行如下的测试。\r\n\r\n一般情况下，我们在测试之前，首先要明白的一件事是：弄懂需求，没有需求的测试都是扯淡。例如：一个网站，需要有这样一项该网站最多只有5个人来进行同时访问。如果我们知道这个需求，在我们测试的时候就需要在性能测试中测试并发数很高的测试用例。\r\n\r\n用户需求：有一个登陆界面，界面中有两个textbox，一个按钮。请针对这个需求设计相应的test case。\r\n\r\n需求明确后，我们开始从如下一些方面考虑测试用例。\r\n\r\n#1、功能测试\r\n\r\n1.1）用户名和密码均正确，点击登录按钮验证是否可以登录成功，并跳转至登录成功界面。\r\n\r\n1.2）用户名和密码不匹配(即至少有一个错误)，点击登录按钮验证是否登录失败，并提示相关错误提示信息。其中包括不输入用户名和密码，直接点击提交按钮，是否有相应的提示\r\n\r\n1.3）用户名和密码过长和过短是否有相应的提示\r\n\r\n1.4）用户名和密码是否允许有特殊字符的情况\r\n\r\n1.5) 用户名和密码输入前后如果有空格的处理方式\r\n\r\n1.6）是否有记住密码这一功能\r\n\r\n1.7) 密码是否是以XXX的格式隐藏显示的\r\n\r\n#2、界面测试\r\n\r\n2.1）布局是否合理。例如：2个textbox是否是对齐的\r\n\r\n2.2）textbox、button的大小是否合适，是否符合需求\r\n\r\n2.3）界面是否漂亮\r\n\r\n2.4）登陆成功或失败时错误或成功提示信息是否友好\r\n\r\n#3、性能测试\r\n\r\n3.1）打开登陆界面需要几秒\r\n\r\n3.2）登陆成功后跳转到成功界面需要几秒。\r\n\r\n3.3）登陆失败给出的提示显示需要几秒\r\n\r\n3.4）支持多少人同时访问，即并发数\r\n\r\n#4、安全性测试\r\n\r\n4.1）用户登陆成功后，保存的cookie是否是代理的.否则容易被外人盗用\r\n\r\n4.2）用户名和密码的验证是否是在服务器端进行，而不是在客服端进行。\r\n\r\n4.3）用户名和密码的提交方式是get还是post，不能使用get方法进行显示提交密码，要使用post方法将用户名和密码作为数据传输到服务器端。\r\n\r\n4.4）登陆界面的textbox是否禁止了脚本输入，以防止爬虫。\r\n\r\n4.5）是否限制了错误登陆的次数。以防止暴力破解\r\n\r\n#5、兼容性测试\r\n\r\n5.1）是否兼容所有浏览器，其中包括：IE各种版本、FF、Chrome\r\n\r\n5.2）是否在浏览器的各个大小下能正常显示工作\r\n\r\n5.3）是否兼容各种平台，例如：Windows、Mac等\r\n\r\n5.4）是否能在移动平台下正常工作。\r\n\r\n#6、可用性测试\r\n\r\n6.1）是否支持键盘的输入\r\n\r\n6.2）是否支持快捷键，例如：输入好用户名和密码之后按回车键就自动登陆。\r\n\r\n#7、其它特殊情况测试\r\n\r\n7.1）用户登录后修改密码是否还能继续操作\r\n\r\n7.2）同一用户同时通过不同浏览器登录上，是否会导致另一客户端下线\r\n\r\n7.3）同一用户多点相同操作，是否对操作加锁的测试\r\n\r\n#8本地化测试 （Localization test）\r\n\r\n不同语言环境下，页面的显示是否正确。\r\n\r\n#9辅助性测试 （Accessibility test）\r\n\r\n辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能\r\n1. 高对比度下能否显示正常 （视力不好的人使用）','<p>当我们写一个登陆界面，为使其更好的工作，也为了有更好的用户体验，我们需要对登陆界面进行如下的测试。</p><p>一般情况下，我们在测试之前，首先要明白的一件事是：弄懂需求，没有需求的测试都是扯淡。例如：一个网站，需要有这样一项该网站最多只有5个人来进行同时访问。如果我们知道这个需求，在我们测试的时候就需要在性能测试中测试并发数很高的测试用例。</p><p>用户需求：有一个登陆界面，界面中有两个textbox，一个按钮。请针对这个需求设计相应的test case。</p><p>需求明确后，我们开始从如下一些方面考虑测试用例。</p><h1>1、功能测试</h1><p>1.1）用户名和密码均正确，点击登录按钮验证是否可以登录成功，并跳转至登录成功界面。</p><p>1.2）用户名和密码不匹配(即至少有一个错误)，点击登录按钮验证是否登录失败，并提示相关错误提示信息。其中包括不输入用户名和密码，直接点击提交按钮，是否有相应的提示</p><p>1.3）用户名和密码过长和过短是否有相应的提示</p><p>1.4）用户名和密码是否允许有特殊字符的情况</p><p>1.5) 用户名和密码输入前后如果有空格的处理方式</p><p>1.6）是否有记住密码这一功能</p><p>1.7) 密码是否是以XXX的格式隐藏显示的</p><h1>2、界面测试</h1><p>2.1）布局是否合理。例如：2个textbox是否是对齐的</p><p>2.2）textbox、button的大小是否合适，是否符合需求</p><p>2.3）界面是否漂亮</p><p>2.4）登陆成功或失败时错误或成功提示信息是否友好</p><h1>3、性能测试</h1><p>3.1）打开登陆界面需要几秒</p><p>3.2）登陆成功后跳转到成功界面需要几秒。</p><p>3.3）登陆失败给出的提示显示需要几秒</p><p>3.4）支持多少人同时访问，即并发数</p><h1>4、安全性测试</h1><p>4.1）用户登陆成功后，保存的cookie是否是代理的.否则容易被外人盗用</p><p>4.2）用户名和密码的验证是否是在服务器端进行，而不是在客服端进行。</p><p>4.3）用户名和密码的提交方式是get还是post，不能使用get方法进行显示提交密码，要使用post方法将用户名和密码作为数据传输到服务器端。</p><p>4.4）登陆界面的textbox是否禁止了脚本输入，以防止爬虫。</p><p>4.5）是否限制了错误登陆的次数。以防止暴力破解</p><h1>5、兼容性测试</h1><p>5.1）是否兼容所有浏览器，其中包括：IE各种版本、FF、Chrome</p><p>5.2）是否在浏览器的各个大小下能正常显示工作</p><p>5.3）是否兼容各种平台，例如：Windows、Mac等</p><p>5.4）是否能在移动平台下正常工作。</p><h1>6、可用性测试</h1><p>6.1）是否支持键盘的输入</p><p>6.2）是否支持快捷键，例如：输入好用户名和密码之后按回车键就自动登陆。</p><h1>7、其它特殊情况测试</h1><p>7.1）用户登录后修改密码是否还能继续操作</p><p>7.2）同一用户同时通过不同浏览器登录上，是否会导致另一客户端下线</p><p>7.3）同一用户多点相同操作，是否对操作加锁的测试</p><h1>8本地化测试 （Localization test）</h1><p>不同语言环境下，页面的显示是否正确。</p><h1>9辅助性测试 （Accessibility test）</h1><p>辅助功能测试是指测试软件是否向残疾用户提供足够的辅助功能</p><ol><li>高对比度下能否显示正常 （视力不好的人使用）</li></ol>','当我们写一个登陆界面，为使其更好的工作，也为了有更好的用户体验，我们需要对登陆界面进行如下的测试。一般情况下，我们在测试之前，首先要明白的一件事是：弄懂需求，没有需求的测试都是扯淡。例如：一个网站，需要有这样一项该网站最多只有5个人来进行同时访问。如果我们知道这个需求，在我们测试的时候就需要在性能测试中测试并发数很高的测试用例。用户需求：有一个登陆界面，界面中有两个textbox，...','测试','uploads/article/default.jpg',0,3,'2018-03-17 00:15:29','2018-03-19 23:22:08',NULL),(6,2,'1~10的序列，一次取一个或者连续的两个；最后取的获胜。第一个取的怎么取才能肯定获胜','汤一碗','这类题型的解法较为简单。\r\n\r\n即从**一个N长**序列中取出**m个或n个**，问第一次取几个可以获胜。\r\n\r\n解为：第一次取**N/(m+n)的余数**个，如该题第一次只需取1个，剩下9个，对方取1，己方取2，对方取2，己方取1，即可确保获胜。\r\n\r\n#### 该题可扩展为多序列多取法题型，参考知乎问题\r\n\r\n> 三堆数量随机的石头，两个人轮流从其中一堆中拿走任意数量的石头，拿走最后一块的人输，必胜法是什么？\r\n[组合游戏](https://www.zhihu.com/question/27467617/ \"组合游戏\")','<p>这类题型的解法较为简单。</p><p>即从<strong>一个N长</strong>序列中取出<strong>m个或n个</strong>，问第一次取几个可以获胜。</p><p>解为：第一次取<strong>N/(m+n)的余数</strong>个，如该题第一次只需取1个，剩下9个，对方取1，己方取2，对方取2，己方取1，即可确保获胜。</p><h4>该题可扩展为多序列多取法题型，参考知乎问题</h4><blockquote>三堆数量随机的石头，两个人轮流从其中一堆中拿走任意数量的石头，拿走最后一块的人输，必胜法是什么？<br><a href=\"https://www.zhihu.com/question/27467617/\">组合游戏</a></blockquote>','这类题型的解法较为简单。即从一个N长序列中取出m个或n个，问第一次取几个可以获胜。解为N/(m+n)的余数，如该题第一次只需取1个，剩下9个，对方取1，己方取2，对方取2，己方取1，即可确保获胜。该题可扩展为多序列多取法题型，参考知乎问题 三堆数量随机的石头，两个人轮流从其中一堆中拿走任意数量的石头，拿走最后一块的人输，必胜法是什么？','组合游戏,异或,Nim','uploads/article/default.jpg',0,4,'2018-03-17 00:38:45','2018-03-24 12:20:01',NULL),(7,2,'找出单链表中的倒数第k个元素','汤一碗','解题思路：\r\n> 为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 \r\n如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。 \r\n存在另一种更高效的方法。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置\r\n\r\n程序如下：\r\n\r\n```c\r\npublic Node findElem(Node head,int k){\r\n        if(k<1 || head == null)\r\n        {\r\n            return null;\r\n        }\r\n        Node p1 = head;\r\n        Node p2 = head;\r\n        for (int i = 0; i < k - 1; i++) { //前移k-1步\r\n            if(p1.next != null){\r\n                p1 = p1.next;\r\n            }else {\r\n                return null;\r\n            }\r\n\r\n        }\r\n        while (p1 != null) {\r\n            p1 = p1.next;\r\n            p2 = p2.next;\r\n        }\r\n        return p2;\r\n    }\r\n	```','<p>解题思路：</p><blockquote>为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第n-k个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第n-k个元素。 <br>如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如下：依次对链表的每一个结点元素进行这样的测试，遍历k个元素，查看是否到达链表尾，直到找到那个倒数第k个元素。此种方法将对同一批元素进行反复多次的遍历，对于链表的大部分元素而言，都要遍历k个元素，如果链表长度为n，则该算法时间复杂度为O(kn)级，效率太低。 <br>存在另一种更高效的方法。在查找过程中，设置两个指针，让其中一个指针比另一个指针先前移k-1步，然后两个指针同时往前移动。循环直到先行的指针指为NULL时，另一个指针所指的位置就是所要找的位置</blockquote><p>程序如下：</p><pre><code class=\"lang-c\">public Node findElem(Node head,int k){\n        if(k&lt;1 || head == null)\n        {\n            return null;\n        }\n        Node p1 = head;\n        Node p2 = head;\n        for (int i = 0; i &lt; k - 1; i++) { //前移k-1步\n            if(p1.next != null){\n                p1 = p1.next;\n            }else {\n                return null;\n            }\n\n        }\n        while (p1 != null) {\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p2;\n    }</code></pre>','解题思路： 为了求出链表中的倒数第k个元素，最容易想到的方法是首先遍历一遍单链表，求出整个单链表的长度n，然后将倒数第k个，转换为正数第nk个，接下去遍历一次就可以得到结果。不过这种方法需要对链表进行两次遍历，第一次遍历用于求解单链表的长度，第二次遍历用于查找正数第nk个元素。 如果沿从头至尾的方向从链表中的某个元素开始，遍历k个元素刚好到达链表尾，那么元素就是要找的倒数第k个元素。设计如...','算法,链表','uploads/article/default.jpg',0,4,'2018-03-17 00:44:13','2018-03-25 14:13:02',NULL),(8,2,'互联网测试与传统测试的不同','汤一碗','#1.测试周期较短，产品功能更新上线较快\r\n测试完了一般直接就发布了，所以不像传统的软件有那么长的测试周期，包括internal beta，external beta等过程，而且我了解到的情况，很多基于web的互联网产品平均一天有多个发布，可大可小。所以发布可能就成了测试人员的工作，当然有相关的系统的支持。 这里还需要考虑的问题是常见的基于各种条件的灰度发布，先让部分用户用起来。发布完了之后还要做现网的验证。\r\n#2.测试环节需要更多的人参与\r\na. 开发人员的自测。 \r\n    测试耗费更多时间很多时候是因为代码的质量不够好，有很多bug，有很多讨论，很多的拉代码的次数。所以提高开发提交的代码质量就是一个很重要的方面。有些公司是通过开发人员的强制的单元测试来保证的，有些是通过功能级别的自测来保证的。这些可以借助一些数据来反映，比如同一个版本拉代码的次数，或者测试用例的通过率等等。\r\n\r\nb. 产品或者运营人员的体验。\r\n    很多互联网的产品不像传统软件产品，不是一个产品经理来提所有的需求。产品，或者称为产品经理，是一个团队，每人负责一块来提出需求。另外很多需求可能是来自于运营团队，和business相关，或者是不同系统的打通。每个产品经理或者运营，需要在开发人员实现了相应的功能之后到体验环境里面来试用产品，就是所谓的体验，看这些功能是不是他们想要的。这样就可以在测试人员测试之前保证没有明显的需求理解的问题，避免浪费测试的人力和时间。\r\n\r\nc. 发布之前的评审。\r\n    不同的角色进来看对于一个已经测完的工作还有没有问题，以及发布的时候需要注意的问题，环境的问题，配置的问题，数据的问题等等。\r\n\r\n#3.用户基数大，产品使用环境杂\r\na. 如何来保证或者验证性能\r\n     传统软件的性能测试相对要单纯一些，可以比较容易搭建一套环境，流量也比较容易模拟。而互联网的一个产品可能有几百上千台甚至更多的服务器，多地多层部署，受到各种因素的影响，比如广告促销活动，一下子流量可以冲到很高。所以这方面的做法也会有所不同，全量的模拟不太现实，而且如上面所说，发布非常快，也没有那么多的时间去反复的做性能测试。所以如何来做比较轻量级的性能测试也是一个很大的课题。\r\n\r\nb. 浏览器的兼容性。\r\n    用户使用的浏览器种类可能非常多，包括大家都在骂的IE6，还有IE9的n种模式，版本更新速度火箭一般的Chrome和Firefox，以及很多种国产的浏览器。要一一覆盖是一个很大的挑战，其实不可能，但是产品团队肯定希望测试能够覆盖更多。对于一些企业级的产品可以宣称就支持很少的几种，但是互联网产品很难这样做，那就等于放弃一些用户。如何来设计策略？有没有技术手段？\r\n\r\nc. 一个小的改动引起的问题可以影响到无数的用户，而且很多时候马上会被发现，那个压力还是非常大的。整个修复的过程也是带电操作，没有那么多环境和时间来在内部慢慢调整，如何来保证修复的质量？\r\n\r\n#4.需要了解更多产品、设计、开发等技术知识\r\n\r\n[互联网测试的不同](httphttp://blog.csdn.net/superqa/article/details/7430619:// \"互联网测试的不同\")','<h1>1.测试周期较短，产品功能更新上线较快</h1><p>测试完了一般直接就发布了，所以不像传统的软件有那么长的测试周期，包括internal beta，external beta等过程，而且我了解到的情况，很多基于web的互联网产品平均一天有多个发布，可大可小。所以发布可能就成了测试人员的工作，当然有相关的系统的支持。 这里还需要考虑的问题是常见的基于各种条件的灰度发布，先让部分用户用起来。发布完了之后还要做现网的验证。</p><h1>2.测试环节需要更多的人参与</h1><p>a. 开发人员的自测。</p><pre><code>测试耗费更多时间很多时候是因为代码的质量不够好，有很多bug，有很多讨论，很多的拉代码的次数。所以提高开发提交的代码质量就是一个很重要的方面。有些公司是通过开发人员的强制的单元测试来保证的，有些是通过功能级别的自测来保证的。这些可以借助一些数据来反映，比如同一个版本拉代码的次数，或者测试用例的通过率等等。\n</code></pre><p>b. 产品或者运营人员的体验。</p><pre><code>很多互联网的产品不像传统软件产品，不是一个产品经理来提所有的需求。产品，或者称为产品经理，是一个团队，每人负责一块来提出需求。另外很多需求可能是来自于运营团队，和business相关，或者是不同系统的打通。每个产品经理或者运营，需要在开发人员实现了相应的功能之后到体验环境里面来试用产品，就是所谓的体验，看这些功能是不是他们想要的。这样就可以在测试人员测试之前保证没有明显的需求理解的问题，避免浪费测试的人力和时间。\n</code></pre><p>c. 发布之前的评审。</p><pre><code>不同的角色进来看对于一个已经测完的工作还有没有问题，以及发布的时候需要注意的问题，环境的问题，配置的问题，数据的问题等等。\n</code></pre><h1>3.用户基数大，产品使用环境杂</h1><p>a. 如何来保证或者验证性能</p><pre><code> 传统软件的性能测试相对要单纯一些，可以比较容易搭建一套环境，流量也比较容易模拟。而互联网的一个产品可能有几百上千台甚至更多的服务器，多地多层部署，受到各种因素的影响，比如广告促销活动，一下子流量可以冲到很高。所以这方面的做法也会有所不同，全量的模拟不太现实，而且如上面所说，发布非常快，也没有那么多的时间去反复的做性能测试。所以如何来做比较轻量级的性能测试也是一个很大的课题。\n</code></pre><p>b. 浏览器的兼容性。</p><pre><code>用户使用的浏览器种类可能非常多，包括大家都在骂的IE6，还有IE9的n种模式，版本更新速度火箭一般的Chrome和Firefox，以及很多种国产的浏览器。要一一覆盖是一个很大的挑战，其实不可能，但是产品团队肯定希望测试能够覆盖更多。对于一些企业级的产品可以宣称就支持很少的几种，但是互联网产品很难这样做，那就等于放弃一些用户。如何来设计策略？有没有技术手段？\n</code></pre><p>c. 一个小的改动引起的问题可以影响到无数的用户，而且很多时候马上会被发现，那个压力还是非常大的。整个修复的过程也是带电操作，没有那么多环境和时间来在内部慢慢调整，如何来保证修复的质量？</p><h1>4.需要了解更多产品、设计、开发等技术知识</h1><p><a href=\"httphttp://blog.csdn.net/superqa/article/details/7430619://\">互联网测试的不同</a></p>','1.测试周期较短，产品功能更新上线较快测试完了一般直接就发布了，所以不像传统的软件有那么长的测试周期，包括internal beta，external beta等过程，而且我了解到的情况，很多基于web的互联网产品平均一天有多个发布，可大可小。所以发布可能就成了测试人员的工作，当然有相关的系统的支持。 这里还需要考虑的问题是常见的基于各种条件的灰度发布，先让部分用户用起来。发布完了之后还要做现...','测试','uploads/article/default.jpg',0,2,'2018-03-17 17:46:56','2018-03-20 04:27:17',NULL),(9,2,'进程、挂起、线程、死锁、中断、陷入······','汤一碗','#进程：\r\n程序的一次执行过程。进程是动态的，而程序是静态的。进程有五种状态，三种基本状态，四种特征，是系统资源分配和调度的独立单位。程序段，相关数据段，进程控制块（存了四种信息）构成了进程实体。\r\n#挂起\r\n为了系统和用户观察和分析进程的需要，还需引用挂起操作：如果进程正在执行，它将暂停执行，暂不接受调度。与挂起操作对应的是**激活**操作。挂起的引入有四种原因。\r\n1. 终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。\r\n2. 父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。\r\n3. 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。 \r\n4. 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。 \r\n5. 对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。\r\n\r\n#线程：\r\n引入原因：\r\n1. 提高资源利用率和系统吞吐量。\r\n2. 其为调度和分派的基本单位。\r\n3. 执行就绪阻塞态。有线程控制块TCB.两种实现方式。\r\n4. 创建有初始化线程，中止由函数。\r\n\r\n#死锁：\r\n是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\r\n**两个或多个线程相互等待对方释放锁，则会出现死锁现象。**\r\n![死锁](/uploads/article/20180317/5aad32c7a313b.png \"死锁\")\r\n### 其有四个必要条件。\r\n1. 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。\r\n\r\n2. 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。\r\n\r\n3. 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。\r\n\r\n4. 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。\r\n\r\n###死锁预防\r\n\r\n1. 加锁顺序\r\n当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。这种方式是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。\r\n\r\n2. 加锁时限\r\n在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁。\r\n\r\n3. 死锁检测（检测死锁的比如有jstack）\r\n死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，会在线程和锁相关的数据结构中（map等等）将其记下。\r\n\r\n4. 除此之外，每当有线程请求锁，也需要记录在这个数据结构中。检测到死锁之后：\r\n一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。\r\n\r\n5. 一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。\r\n\r\n#活锁:\r\n是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。\r\n\r\n任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。\r\n\r\n###活锁的解决方法\r\n解决协同活锁的一种方案是调整重试机制。\r\n比如引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。 典型的例子是以太网的CSMA/CD检测机制。\r\n另外为了避免可能的死锁，适当加入一定的重试次数也是有效的解决办法。尽管这在业务上会引起一些复杂的逻辑处理。\r\n比如约定重试机制避免再次冲突。 例如自动驾驶的防碰撞系统（假想的例子），可以根据序列号约定检测到相撞风险时，序列号小的飞机朝上飞， 序列号大的飞机朝下飞。\r\n\r\n#饥饿\r\n是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。\r\n\r\n#中断：\r\n程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预选安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为相应的服务程序去处理，这个过程称为程序中断。\r\n\r\n#轮询\r\n轮询(Polling)I／O方式或程序控制I／O方式，是让CPU以一定的周期按次序查询每一个外设，看它是否有数据输入或输出的要求，若有，则进行相应的输入／输出服务；若无，或I／O处理完毕柏，CPU就接着查询下一个外设。\r\n\r\n#陷入：\r\ncpu内部时间所引起的中断。又称内中断。','<h1>进程：</h1><p>程序的一次执行过程。进程是动态的，而程序是静态的。进程有五种状态，三种基本状态，四种特征，是系统资源分配和调度的独立单位。程序段，相关数据段，进程控制块（存了四种信息）构成了进程实体。</p><h1>挂起</h1><p>为了系统和用户观察和分析进程的需要，还需引用挂起操作：如果进程正在执行，它将暂停执行，暂不接受调度。与挂起操作对应的是<strong>激活</strong>操作。挂起的引入有四种原因。</p><ol><li>终端用户的请求。当终端用户在自己的程序运行期间发现有可疑问题时，希望暂停使自己的程序静止下来。亦即，使正在执行的进程暂停执行；若此时用户进程正处于就绪状态而未执行，则该进程暂不接受调度，以便用户研究其执行情况或对程序进行修改。我们把这种静止状态成为“挂起状态”。</li><li>父进程的请求。有时父进程希望挂起自己的某个子进程，以便考察和修改子进程，或者协调各子进程间的活动。</li><li>负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。</li><li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li><li>对换的需要。为了缓和内存紧张的情况，将内存中处于阻塞状态的进程换至外存上。</li></ol><h1>线程：</h1><p>引入原因：</p><ol><li>提高资源利用率和系统吞吐量。</li><li>其为调度和分派的基本单位。</li><li>执行就绪阻塞态。有线程控制块TCB.两种实现方式。</li><li>创建有初始化线程，中止由函数。</li></ol><h1>死锁：</h1><p>是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。<br><strong>两个或多个线程相互等待对方释放锁，则会出现死锁现象。</strong><br><img src=\"/uploads/article/20180317/5aad32c7a313b.png\" alt=\"死锁\" title=\"死锁\"></p><h3>其有四个必要条件。</h3><ol><li>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li><li>请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li>环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li></ol><h3>死锁预防</h3><ol><li>加锁顺序</li></ol><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。这种方式是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的。</p><ol><li>加锁时限</li></ol><p>在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁。</p><ol><li>死锁检测（检测死锁的比如有jstack）</li></ol><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。每当一个线程获得了锁，会在线程和锁相关的数据结构中（map等等）将其记下。</p><ol><li>除此之外，每当有线程请求锁，也需要记录在这个数据结构中。检测到死锁之后：</li></ol><p>一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁。</p><ol><li>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li></ol><h1>活锁:</h1><p>是指线程1可以使用资源，但它很礼貌，让其他线程先使用资源，线程2也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p><p>任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><h3>活锁的解决方法</h3><p>解决协同活锁的一种方案是调整重试机制。<br>比如引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。 典型的例子是以太网的CSMA/CD检测机制。<br>另外为了避免可能的死锁，适当加入一定的重试次数也是有效的解决办法。尽管这在业务上会引起一些复杂的逻辑处理。<br>比如约定重试机制避免再次冲突。 例如自动驾驶的防碰撞系统（假想的例子），可以根据序列号约定检测到相撞风险时，序列号小的飞机朝上飞， 序列号大的飞机朝下飞。</p><h1>饥饿</h1><p>是指如果线程T1占用了资源R，线程T2又请求封锁R，于是T2等待。T3也请求资源R，当T1释放了R上的封锁后，系统首先批准了T3的请求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求......，T2可能永远等待。</p><h1>中断：</h1><p>程序中断通常简称中断，是指CPU在正常运行程序的过程中，由于预选安排或发生了各种随机的内部或外部事件，使CPU中断正在运行的程序，而转到为相应的服务程序去处理，这个过程称为程序中断。</p><h1>轮询</h1><p>轮询(Polling)I／O方式或程序控制I／O方式，是让CPU以一定的周期按次序查询每一个外设，看它是否有数据输入或输出的要求，若有，则进行相应的输入／输出服务；若无，或I／O处理完毕柏，CPU就接着查询下一个外设。</p><h1>陷入：</h1><p>cpu内部时间所引起的中断。又称内中断。</p>','进程：程序的一次执行过程。进程是动态的，而程序是静态的。进程有五种状态，三种基本状态，四种特征，是系统资源分配和调度的独立单位。程序段，相关数据段，进程控制块（存了四种信息）构成了进程实体。挂起为了系统和用户观察和分析进程的需要，还需引用挂起操作：如果进程正在执行，它将暂停执行，暂不接受调度。与挂起操作对应的是激活操作。挂起的引入有四种原因。线程：引入原因：提高资源利用率和系统...','进程,挂起,线程,死锁,中断,陷入','/uploads/article/20180317/5aad32c7a313b.png',0,3,'2018-03-17 18:24:45','2018-03-19 22:56:38',NULL),(10,2,'unix进程间的通信方式','汤一碗','1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。\r\n（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。\r\n（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。\r\n（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺\r\n（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。\r\n（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。\r\n（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。\r\n（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。','<p>1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。<br>（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。<br>（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。<br>（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺<br>（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。<br>（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。<br>（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<br>（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>','1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。\r\n（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。\r\n（3）信号（Signal）：信号是比较复杂的通信...','进程,进程通信','uploads/article/default.jpg',0,3,'2018-03-18 16:02:58','2018-03-25 14:12:53',NULL),(11,2,'linux几种创建进程的方法','汤一碗','在Linux中主要提供了fork、vfork、clone三个进程创建方法。 \r\n在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。 \r\n\r\nfork \r\n    fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。例如，要是父进程打开了五个文件，那么子进程也有五个打开的文件，而且这些文件的当前读写指针也停在相同的地方。所以，这一步所做的是复制。这样得到的子进程独立于父进程， 具有良好的并发性，但是二者之间的通讯需要通过专门的通讯机制，如：pipe，共享内存等机制， 另外通过fork创建子进程，需要将上面描述的每种资源都复制一个副本。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。若后来确实发生了写入，那意味着parent和child的数据不一致了，于是产生复制动作，每个进程拿到属于自己的那一份，这样就可以降低系统调用的开销。所以有了写时复制后呢，vfork其实现意义就不大了。 \r\n\r\n　　fork()调用执行一次返回两个值，对于父进程，fork函数返回子程序的进程号，而对于子程序，fork函数则返回零，这就是一个函数返回两次的本质。 \r\n\r\n　　在fork之后，子进程和父进程都会继续执行fork调用之后的指令。子进程是父进程的副本。它将获得父进程的数据空间，堆和栈的副本，这些都是副本，父子进程并不共享这部分的内存。也就是说，子进程对父进程中的同名变量进行修改并不会影响其在父进程中的值。但是父子进程又共享一些东西，简单说来就是程序的正文段。正文段存放着由cpu执行的机器指令，通常是read-only的。下面是一个验证的例子： \r\n\r\n　　例１：fork.c \r\n\r\n　　#include<stdio.h> \r\n\r\n　　#include<sys/types.h> \r\n\r\n　　#include<unistd.h> \r\n\r\n　　#include<errno.h> \r\n\r\n　　int main() \r\n\r\n　　{ \r\n\r\n　　int a = 5; \r\n\r\n　　int b = 2; \r\n\r\n　　pid_t pid; \r\n\r\n　　pid = fork(); \r\n\r\n　　if(pid == 0) { \r\n\r\n　　a = a-4; \r\n\r\n　　printf(\"I\'m a child process with PID [%d],the value of a: %d,the value of b:%d.\\n\",pid,a,b); \r\n\r\n　　}else if(pid < 0) { \r\n\r\n　　perror(\"fork\"); \r\n\r\n　　}else { \r\n\r\n　　printf(\"I\'m a parent process, with PID [%d], the value of a: %d, the value of b:%d.\\n\", pid, a, b); \r\n\r\n　　} \r\n\r\n　　return 0; \r\n\r\n　　} \r\n\r\n　　#gcc –o fork fork.c \r\n\r\n　　#./fork \r\n\r\n　　运行结果： \r\n\r\n　　I’m a child process with PID[0],the value of a:1,the value of b:2. \r\n\r\n　　I’m a parent process with PID[19824],the value of a:5,the value of b:2. \r\n\r\n　　可见，子进程中将变量a的值改为１,而父进程中则保持不变。 \r\n\r\n　　vfork \r\n\r\n　　vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。 \r\n\r\n　　因此，上面的例子如果改用vfork()的话，那么两次打印a,b的值是相同的，所在地址也是相同的。 \r\n\r\n　　但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。 \r\n\r\n　　Vfork也是在父进程中返回子进程的进程号，在子进程中返回0。 \r\n\r\n　　用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。下面这个例子可以验证子进程调用exec时父进程是否真的已经结束阻塞： \r\n\r\n　　例2：execl.c \r\n\r\n```c\r\n　　#include<stdlib.h> \r\n\r\n　　#include<sys/types.h> \r\n\r\n　　#include<sys/wait.h> \r\n\r\n　　#include<unistd.h> \r\n\r\n　　#include<stdio.h> \r\n\r\n　　#include<errno.h> \r\n\r\n　　#include<string.h> \r\n\r\n　　int main() \r\n\r\n　　{ \r\n　　int a = 1; \r\n　　int b = 2; \r\n　　pid_t pid; \r\n　　int status; \r\n    pid = vfork(); \r\n    if(pid == -1) { \r\n       perror(\"Fork failed to creat a process\"); \r\n       exit(1); \r\n       }\r\n    else if(pid == 0) \r\n       { \r\n           // sleep(3); \r\n            if(execl(\"/bin/example\",\"example\",NULL)<0) \r\n            { \r\n                 perror(\"Exec failed\"); \r\n                 exit(1); \r\n            } \r\n            exit(0); \r\n        // }else // if(pid != wait(&status)) { \r\n              // perror(\"A Signal occured before the child exited\"); }\r\n     else \r\n      printf(\"parent process,the value of a :%d, b:%d, addr of a: %p,b: %p\\n\",a,b,&a,&b); exit(0); } \r\n```\r\nExample.c \r\n```c\r\n#include<stdio.h> \r\nint main() \r\n{ \r\n   int a = 1;\r\n   int b = 2;\r\n   sleep(3);\r\n   printf(\"Child process,the value of a is %d,b is %d,the address a %p,b %p\\n\",a,b,&a,&b); \r\n   return 0; \r\n} \r\n```\r\n#gcc –o execl execl.c #./ execl 运行结果：\r\nChild process ,The value of a is 1,b is 2,the address a 0xbfb73d90,b 0xbfb73d8c \r\n\r\n　　如果将注释掉的三行加入程序的话，由于父进程wait()而阻塞，因此即使此时子进程阻塞，父进程也得不到运行，因此运行结果如下： \r\n\r\n　　The value of a is 1,b is 2,the address a 0xbfb73d90,b 0xbfb73d8c \r\n\r\n　　Parent process,the value of a:1,b:2,addr ofa:0xbfaa710c, b:0xbf aa7108 \r\n\r\n　　另外还应注意的是在它调用exec后父进程才可能调度运行，因此sleep(3)函数必须放在example程序中才能生效。 \r\n\r\n　　clone \r\n\r\n　　系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。下面来看一个例子： \r\n\r\n　　例3：clone.c \r\n```c\r\n　　#include <stdio.h> \r\n\r\n　　#include <stdlib.h> \r\n\r\n　　#include <sched.h> \r\n\r\n　　#include <unistd.h> \r\n\r\n　　#include <fcntl.h> \r\n\r\n　　#include <sys/types.h> \r\n\r\n　　#include <sys/stat.h> \r\n\r\n　　int variable,fd; \r\n\r\n　　int do_something() { \r\n\r\n　　variable = 42; \r\n\r\n　　printf(\"in child process\\n\"); \r\n\r\n　　close(fd); \r\n\r\n　　// _exit(0); \r\n\r\n　　return 0; \r\n\r\n　　} \r\n\r\n　　int main(int argc, char *argv[]) { \r\n\r\n　　void *child_stack; \r\n\r\n　　char tempch; \r\n\r\n　　variable = 9; \r\n\r\n　　fd = open(\"/test.txt\",O_RDONLY); \r\n\r\n　　child_stack = (void *)malloc(16384); \r\n\r\n　　printf(\"The variable was %d\\n\",variable); \r\n\r\n　　clone(do_something, child_stack+10000, CLONE_VM |CLONE_FILES,NULL); \r\n\r\n　　sleep(3); /* 延时以便子进程完成关闭文件操作、修改变量 */ \r\n\r\n　　printf(\"The variable is now %d\\n\",variable); \r\n\r\n　　if(read(fd,&tempch,1) < 1) { \r\n\r\n　　perror(\"File Read Error\"); \r\n\r\n　　exit(1); \r\n\r\n　　} \r\n\r\n　　printf(\"We could read from the file\\n\"); \r\n\r\n　　return 0; \r\n\r\n　　} \r\n```\r\n　　#gcc –o clone clone.c \r\n\r\n　　#./clone \r\n\r\n　　运行结果： \r\n\r\n　　the value was 9 \r\n\r\n　　in child process \r\n\r\n　　The variable is now 42 \r\n\r\n　　File Read Error \r\n\r\n　　从程序的输出结果可以看出： \r\n\r\n　　子进程将文件关闭并将变量修改（调用clone时用到的CLONE_VM、CLONE_FILES标志将使得变量和文件描述符表被共享），父进程随即就感觉到了，这就是clone的特点。由于此处没有设置标志CLONE_VFORK，因此子进程在运行时父进程也不会阻塞，两者同时运行。 \r\n\r\n　　总结 \r\n\r\n　　一、fork \r\n\r\n　　1. 调用方法 \r\n\r\n　　#include <sys/types.h> \r\n   #include <unistd.h> \r\n   pid_t fork(void); \r\n   正确返回：在父进程中返回子进程的进程号，在子进程中返回0 \r\n　　错误返回：-1 \r\n\r\n　　2. fork函数调用的用途 \r\n\r\n　　一个进程希望复制自身，从而父子进程能同时执行不同段的代码。 \r\n\r\n　　二、vfork \r\n\r\n　　1. 调用方法 \r\n\r\n　　与fork函数完全相同 \r\n\r\n　　#include <sys/types.h> \r\n\r\n　　#include <unistd.h> \r\n\r\n　　pid_t vfork(void); \r\n\r\n　　正确返回：在父进程中返回子进程的进程号，在子进程中返回0 \r\n\r\n　　错误返回：-1 \r\n\r\n　　2. vfork函数调用的用途 \r\n\r\n　　用vfork创建的进程主要目的是用exec函数执行另外的程序。 \r\n\r\n　　三、clone \r\n\r\n　　1.调用方法 \r\n\r\n　　#include <sched.h> \r\n\r\n　　int clone(int (*fn)(void *), void *child_stack, int flags, void *arg); \r\n\r\n　　正确返回：返回所创建进程的PID，函数中的flags标志用于设置创建子进程时的相关选项，具体含义参看P25 \r\n\r\n　　错误返回：-１ \r\n\r\n　　2.clone()函数调用的用途 \r\n\r\n　　用于有选择地设置父子进程之间需共享的资源 \r\n\r\n　　四、fork，vfork，clone的区别 \r\n\r\n　　1. fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 \r\n\r\n　　2. fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。','<p>在Linux中主要提供了fork、vfork、clone三个进程创建方法。 <br>在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。 </p><p>fork</p><pre><code>fork创建一个进程时，子进程只是完全复制父进程的资源，复制出来的子进程有自己的task_struct结构和pid,但却复制父进程其它所有的资源。例如，要是父进程打开了五个文件，那么子进程也有五个打开的文件，而且这些文件的当前读写指针也停在相同的地方。所以，这一步所做的是复制。这样得到的子进程独立于父进程， 具有良好的并发性，但是二者之间的通讯需要通过专门的通讯机制，如：pipe，共享内存等机制， 另外通过fork创建子进程，需要将上面描述的每种资源都复制一个副本。这样看来，fork是一个开销十分大的系统调用，这些开销并不是所有的情况下都是必须的，比如某进程fork出一个子进程后，其子进程仅仅是为了调用exec执行另一个可执行文件，那么在fork过程中对于虚存空间的复制将是一个多余的过程。但由于现在Linux中是采取了copy-on-write(COW写时复制)技术，为了降低开销，fork最初并不会真的产生两个不同的拷贝，因为在那个时候，大量的数据其实完全是一样的。写时复制是在推迟真正的数据拷贝。若后来确实发生了写入，那意味着parent和child的数据不一致了，于是产生复制动作，每个进程拿到属于自己的那一份，这样就可以降低系统调用的开销。所以有了写时复制后呢，vfork其实现意义就不大了。 \n</code></pre><p>　　fork()调用执行一次返回两个值，对于父进程，fork函数返回子程序的进程号，而对于子程序，fork函数则返回零，这就是一个函数返回两次的本质。 </p><p>　　在fork之后，子进程和父进程都会继续执行fork调用之后的指令。子进程是父进程的副本。它将获得父进程的数据空间，堆和栈的副本，这些都是副本，父子进程并不共享这部分的内存。也就是说，子进程对父进程中的同名变量进行修改并不会影响其在父进程中的值。但是父子进程又共享一些东西，简单说来就是程序的正文段。正文段存放着由cpu执行的机器指令，通常是read-only的。下面是一个验证的例子： </p><p>　　例１：fork.c </p><p>　　#include&lt;stdio.h&gt; </p><p>　　#include&lt;sys/types.h&gt; </p><p>　　#include&lt;unistd.h&gt; </p><p>　　#include&lt;errno.h&gt; </p><p>　　int main() </p><p>　　{ </p><p>　　int a = 5; </p><p>　　int b = 2; </p><p>　　pid_t pid; </p><p>　　pid = fork(); </p><p>　　if(pid == 0) { </p><p>　　a = a-4; </p><p>　　printf(\"I\'m a child process with PID [%d],the value of a: %d,the value of b:%d.n\",pid,a,b); </p><p>　　}else if(pid &lt; 0) { </p><p>　　perror(\"fork\"); </p><p>　　}else { </p><p>　　printf(\"I\'m a parent process, with PID [%d], the value of a: %d, the value of b:%d.n\", pid, a, b); </p><p>　　} </p><p>　　return 0; </p><p>　　} </p><p>　　#gcc –o fork fork.c </p><p>　　#./fork </p><p>　　运行结果： </p><p>　　I’m a child process with PID[0],the value of a:1,the value of b:2. </p><p>　　I’m a parent process with PID[19824],the value of a:5,the value of b:2. </p><p>　　可见，子进程中将变量a的值改为１,而父进程中则保持不变。 </p><p>　　vfork </p><p>　　vfork系统调用不同于fork，用vfork创建的子进程与父进程共享地址空间，也就是说子进程完全运行在父进程的地址空间上，如果这时子进程修改了某个变量，这将影响到父进程。 </p><p>　　因此，上面的例子如果改用vfork()的话，那么两次打印a,b的值是相同的，所在地址也是相同的。 </p><p>　　但此处有一点要注意的是用vfork()创建的子进程必须显示调用exit()来结束，否则子进程将不能结束，而fork()则不存在这个情况。 </p><p>　　Vfork也是在父进程中返回子进程的进程号，在子进程中返回0。 </p><p>　　用 vfork创建子进程后，父进程会被阻塞直到子进程调用exec(exec，将一个新的可执行文件载入到地址空间并执行之。)或exit。vfork的好处是在子进程被创建后往往仅仅是为了调用exec执行另一个程序，因为它就不会对父进程的地址空间有任何引用，所以对地址空间的复制是多余的 ，因此通过vfork共享内存可以减少不必要的开销。下面这个例子可以验证子进程调用exec时父进程是否真的已经结束阻塞： </p><p>　　例2：execl.c</p><pre><code class=\"lang-c\">　　#include&lt;stdlib.h&gt; \n\n　　#include&lt;sys/types.h&gt; \n\n　　#include&lt;sys/wait.h&gt; \n\n　　#include&lt;unistd.h&gt; \n\n　　#include&lt;stdio.h&gt; \n\n　　#include&lt;errno.h&gt; \n\n　　#include&lt;string.h&gt; \n\n　　int main() \n\n　　{ \n　　int a = 1; \n　　int b = 2; \n　　pid_t pid; \n　　int status; \n    pid = vfork(); \n    if(pid == -1) { \n       perror(&quot;Fork failed to creat a process&quot;); \n       exit(1); \n       }\n    else if(pid == 0) \n       { \n           // sleep(3); \n            if(execl(&quot;/bin/example&quot;,&quot;example&quot;,NULL)&lt;0) \n            { \n                 perror(&quot;Exec failed&quot;); \n                 exit(1); \n            } \n            exit(0); \n        // }else // if(pid != wait(&amp;status)) { \n              // perror(&quot;A Signal occured before the child exited&quot;); }\n     else \n      printf(&quot;parent process,the value of a :%d, b:%d, addr of a: %p,b: %p\\n&quot;,a,b,&amp;a,&amp;b); exit(0); } </code></pre><p>Example.c</p><pre><code class=\"lang-c\">#include&lt;stdio.h&gt; \nint main() \n{ \n   int a = 1;\n   int b = 2;\n   sleep(3);\n   printf(&quot;Child process,the value of a is %d,b is %d,the address a %p,b %p\\n&quot;,a,b,&amp;a,&amp;b); \n   return 0; \n} </code></pre><h1>gcc –o execl execl.c #./ execl 运行结果：</h1><p>Child process ,The value of a is 1,b is 2,the address a 0xbfb73d90,b 0xbfb73d8c </p><p>　　如果将注释掉的三行加入程序的话，由于父进程wait()而阻塞，因此即使此时子进程阻塞，父进程也得不到运行，因此运行结果如下： </p><p>　　The value of a is 1,b is 2,the address a 0xbfb73d90,b 0xbfb73d8c </p><p>　　Parent process,the value of a:1,b:2,addr ofa:0xbfaa710c, b:0xbf aa7108 </p><p>　　另外还应注意的是在它调用exec后父进程才可能调度运行，因此sleep(3)函数必须放在example程序中才能生效。 </p><p>　　clone </p><p>　　系统调用fork()和vfork()是无参数的，而clone()则带有参数。fork()是全部复制，vfork()是共享内存，而clone() 是则可以将父进程资源有选择地复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，具体要复制哪些资源给子进程，由参数列表中的 clone_flags来决定。另外，clone()返回的是子进程的pid。下面来看一个例子： </p><p>　　例3：clone.c</p><pre><code class=\"lang-c\">　　#include &lt;stdio.h&gt; \n\n　　#include &lt;stdlib.h&gt; \n\n　　#include &lt;sched.h&gt; \n\n　　#include &lt;unistd.h&gt; \n\n　　#include &lt;fcntl.h&gt; \n\n　　#include &lt;sys/types.h&gt; \n\n　　#include &lt;sys/stat.h&gt; \n\n　　int variable,fd; \n\n　　int do_something() { \n\n　　variable = 42; \n\n　　printf(&quot;in child process\\n&quot;); \n\n　　close(fd); \n\n　　// _exit(0); \n\n　　return 0; \n\n　　} \n\n　　int main(int argc, char *argv[]) { \n\n　　void *child_stack; \n\n　　char tempch; \n\n　　variable = 9; \n\n　　fd = open(&quot;/test.txt&quot;,O_RDONLY); \n\n　　child_stack = (void *)malloc(16384); \n\n　　printf(&quot;The variable was %d\\n&quot;,variable); \n\n　　clone(do_something, child_stack+10000, CLONE_VM |CLONE_FILES,NULL); \n\n　　sleep(3); /* 延时以便子进程完成关闭文件操作、修改变量 */ \n\n　　printf(&quot;The variable is now %d\\n&quot;,variable); \n\n　　if(read(fd,&amp;tempch,1) &lt; 1) { \n\n　　perror(&quot;File Read Error&quot;); \n\n　　exit(1); \n\n　　} \n\n　　printf(&quot;We could read from the file\\n&quot;); \n\n　　return 0; \n\n　　} </code></pre><p>　　#gcc –o clone clone.c </p><p>　　#./clone </p><p>　　运行结果： </p><p>　　the value was 9 </p><p>　　in child process </p><p>　　The variable is now 42 </p><p>　　File Read Error </p><p>　　从程序的输出结果可以看出： </p><p>　　子进程将文件关闭并将变量修改（调用clone时用到的CLONE_VM、CLONE_FILES标志将使得变量和文件描述符表被共享），父进程随即就感觉到了，这就是clone的特点。由于此处没有设置标志CLONE_VFORK，因此子进程在运行时父进程也不会阻塞，两者同时运行。 </p><p>　　总结 </p><p>　　一、fork </p><p>　　1. 调用方法 </p><p>　　#include &lt;sys/types.h&gt; <br>   #include &lt;unistd.h&gt; <br>   pid_t fork(void); <br>   正确返回：在父进程中返回子进程的进程号，在子进程中返回0 <br>　　错误返回：-1 </p><p>　　2. fork函数调用的用途 </p><p>　　一个进程希望复制自身，从而父子进程能同时执行不同段的代码。 </p><p>　　二、vfork </p><p>　　1. 调用方法 </p><p>　　与fork函数完全相同 </p><p>　　#include &lt;sys/types.h&gt; </p><p>　　#include &lt;unistd.h&gt; </p><p>　　pid_t vfork(void); </p><p>　　正确返回：在父进程中返回子进程的进程号，在子进程中返回0 </p><p>　　错误返回：-1 </p><p>　　2. vfork函数调用的用途 </p><p>　　用vfork创建的进程主要目的是用exec函数执行另外的程序。 </p><p>　　三、clone </p><p>　　1.调用方法 </p><p>　　#include &lt;sched.h&gt; </p><p>　　int clone(int (<em>fn)(void </em>), void <em>child_stack, int flags, void </em>arg); </p><p>　　正确返回：返回所创建进程的PID，函数中的flags标志用于设置创建子进程时的相关选项，具体含义参看P25 </p><p>　　错误返回：-１ </p><p>　　2.clone()函数调用的用途 </p><p>　　用于有选择地设置父子进程之间需共享的资源 </p><p>　　四、fork，vfork，clone的区别 </p><p>　　1. fork出来的子进程是父进程的一个拷贝，即，子进程从父进程得到了数据段和堆栈段的拷贝，这些需要分配新的内存；而对于只读的代码段，通常使用共享内存的方式访问；而vfork则是子进程与父进程共享内存空间, 子进程对虚拟地址空间任何数据的修改同样为父进程所见；clone则由用户通过参clone_flags 的设置来决定哪些资源共享，哪些资源拷贝。 </p><p>　　2. fork不对父子进程的执行次序进行任何限制，fork返回后，子进程和父进程都从调用fork函数的下一条语句开始行，但父子进程运行顺序是不定的，它取决于内核的调度算法；而在vfork调用中，子进程先运行，父进程挂起，直到子进程调用了exec或exit之后，父子进程的执行次序才不再有限制；clone中由标志CLONE_VFORK来决定子进程在执行时父进程是阻塞还是运行，若没有设置该标志，则父子进程同时运行，设置了该标志，则父进程挂起，直到子进程结束为止。</p>','在Linux中主要提供了fork、vfork、clone三个进程创建方法。 \r\n在linux源码中这三个调用的执行过程是执行fork(),vfork(),clone()时，通过一个系统调用表映射到sys_fork(),sys_vfork(),sys_clone(),再在这三个函数中去调用do_fork()去做具体的创建进程工作。 \r\n\r\nfork \r\n    fork创建一个进程时，子进程只是完全...','进程,创建进程','uploads/article/default.jpg',0,3,'2018-03-18 17:22:55','2018-03-23 02:33:14',NULL),(12,2,'总结get和post区别','汤一碗','get参数通过url传递，post放在request body中。\r\n\r\nget请求在url中传递的参数是有长度限制的，而post没有。\r\n\r\nget比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。\r\n\r\nget请求只能进行url编码，而post支持多种编码方式\r\n\r\nget请求会浏览器主动cache，而post支持多种编码方式。\r\n\r\nget请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。\r\n\r\nget产生一个TCP数据包，post产生两个TCP数据包。\r\n\r\nGET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。\r\nGET产生一个TCP数据包；POST产生两个TCP数据包。\r\n长的说：\r\n\r\n对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\r\n\r\n而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\r\n\r\nps:\r\n1，http中，GET用于信息获取，而且是安全的和幂等的。\r\n\r\n(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。\r\n\r\n* 注意：这里安全的含义仅仅是指是非修改信息。\r\n\r\n(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。\r\n\r\n2，http中，POST是用于修改服务器上的资源的请求。','<p>get参数通过url传递，post放在request body中。</p><p>get请求在url中传递的参数是有长度限制的，而post没有。</p><p>get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。</p><p>get请求只能进行url编码，而post支持多种编码方式</p><p>get请求会浏览器主动cache，而post支持多种编码方式。</p><p>get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。</p><p>get产生一个TCP数据包，post产生两个TCP数据包。</p><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。<br>GET产生一个TCP数据包；POST产生两个TCP数据包。<br>长的说：</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</p><p>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><p>ps:<br>1，http中，GET用于信息获取，而且是安全的和幂等的。</p><p>(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><ul><li>注意：这里安全的含义仅仅是指是非修改信息。</li></ul><p>(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。</p><p>2，http中，POST是用于修改服务器上的资源的请求。</p>','get参数通过url传递，post放在request body中。get请求在url中传递的参数是有长度限制的，而post没有。get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。get请求只能进行url编码，而post支持多种编码方式get请求会浏览器主动cache，而post支持多种编码方式。get请求参数会被完整保留在浏览历...','get,post,请求','uploads/article/default.jpg',0,3,'2018-03-18 22:30:13','2018-03-21 18:29:58',NULL),(13,2,'TCP和UDP的区别','汤一碗','TCP与UDP基本区别\r\n  1.基于连接与无连接\r\n  2.TCP要求系统资源较多，UDP较少； \r\n  3.UDP程序结构较简单 \r\n  4.流模式（TCP）与数据报模式(UDP); \r\n  5.TCP保证数据正确性，UDP可能丢包 \r\n  6.TCP保证数据顺序，UDP不保证 \r\n　　\r\nUDP应用场景：\r\n  1.面向数据报方式\r\n  2.网络数据大多为短消息 \r\n  3.拥有大量Client\r\n  4.对数据安全性无特殊要求\r\n  5.网络负担非常重，但对响应速度要求高\r\n \r\n具体编程时的区别\r\n   1.socket()的参数不同 \r\n　　 2.UDP Server不需要调用listen和accept \r\n　　 3.UDP收发数据用sendto/recvfrom函数 \r\n　　 4.TCP：地址信息在connect/accept时确定 \r\n　　 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 \r\n　　 6.UDP：shutdown函数无效\r\n \r\n编程区别\r\n   通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。 \r\n　  SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。 \r\n\r\n　　而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。 \r\n\r\n基于上述不同，UDP和TCP编程步骤也有些不同，如下：\r\n\r\nTCP: \r\nTCP编程的服务器端一般步骤是： \r\n　　1、创建一个socket，用函数socket()； \r\n　　2、设置socket属性，用函数setsockopt(); * 可选 \r\n　　3、绑定IP地址、端口等信息到socket上，用函数bind(); \r\n　　4、开启监听，用函数listen()； \r\n　　5、接收客户端上来的连接，用函数accept()； \r\n　　6、收发数据，用函数send()和recv()，或者read()和write(); \r\n　　7、关闭网络连接； \r\n　　8、关闭监听； \r\n\r\nTCP编程的客户端一般步骤是： \r\n　　1、创建一个socket，用函数socket()； \r\n　　2、设置socket属性，用函数setsockopt();* 可选 \r\n　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 \r\n　　4、设置要连接的对方的IP地址和端口等属性； \r\n　　5、连接服务器，用函数connect()； \r\n　　6、收发数据，用函数send()和recv()，或者read()和write(); \r\n　　7、关闭网络连接；\r\n\r\nUDP:\r\n与之对应的UDP编程步骤要简单许多，分别如下： \r\n　　UDP编程的服务器端一般步骤是： \r\n　　1、创建一个socket，用函数socket()； \r\n　　2、设置socket属性，用函数setsockopt();* 可选 \r\n　　3、绑定IP地址、端口等信息到socket上，用函数bind(); \r\n　　4、循环接收数据，用函数recvfrom(); \r\n　　5、关闭网络连接； \r\n\r\nUDP编程的客户端一般步骤是： \r\n　　1、创建一个socket，用函数socket()； \r\n　　2、设置socket属性，用函数setsockopt();* 可选 \r\n　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 \r\n　　4、设置对方的IP地址和端口等属性; \r\n　　5、发送数据，用函数sendto(); \r\n　　6、关闭网络连接；\r\n\r\nTCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。\r\n\r\nUDP补充：\r\n   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。\r\n\r\nTCP补充：\r\n  TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。\r\n\r\n\r\nTCP与UDP区别总结：\r\n1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接\r\n2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付\r\n3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的\r\n  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\r\n4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信\r\n5、TCP首部开销20字节;UDP的首部开销小，只有8个字节\r\n6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道','<p>TCP与UDP基本区别<br>  1.基于连接与无连接<br>  2.TCP要求系统资源较多，UDP较少； <br>  3.UDP程序结构较简单 <br>  4.流模式（TCP）与数据报模式(UDP); <br>  5.TCP保证数据正确性，UDP可能丢包 <br>  6.TCP保证数据顺序，UDP不保证 <br>　　<br>UDP应用场景：<br>  1.面向数据报方式<br>  2.网络数据大多为短消息 <br>  3.拥有大量Client<br>  4.对数据安全性无特殊要求<br>  5.网络负担非常重，但对响应速度要求高</p><p>具体编程时的区别<br>   1.socket()的参数不同 <br>　　 2.UDP Server不需要调用listen和accept <br>　　 3.UDP收发数据用sendto/recvfrom函数 <br>　　 4.TCP：地址信息在connect/accept时确定 <br>　　 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 <br>　　 6.UDP：shutdown函数无效</p><p>编程区别<br>   通常我们在说到网络编程时默认是指TCP编程，即用前面提到的socket函数创建一个socket用于TCP通讯，函数参数我们通常填为SOCK_STREAM。即socket(PF_INET, SOCK_STREAM, 0)，这表示建立一个socket用于流式网络通讯。 <br>　  SOCK_STREAM这种的特点是面向连接的，即每次收发数据之前必须通过connect建立连接，也是双向的，即任何一方都可以收发数据，协议本身提供了一些保障机制保证它是可靠的、有序的，即每个包按照发送的顺序到达接收方。 </p><p>　　而SOCK_DGRAM这种是User Datagram Protocol协议的网络通讯，它是无连接的，不可靠的，因为通讯双方发送数据后不知道对方是否已经收到数据，是否正常收到数据。任何一方建立一个socket以后就可以用sendto发送数据，也可以用recvfrom接收数据。根本不关心对方是否存在，是否发送了数据。它的特点是通讯速度比较快。大家都知道TCP是要经过三次握手的，而UDP没有。 </p><p>基于上述不同，UDP和TCP编程步骤也有些不同，如下：</p><p>TCP: <br>TCP编程的服务器端一般步骤是： <br>　　1、创建一个socket，用函数socket()； <br>　　2、设置socket属性，用函数setsockopt(); * 可选 <br>　　3、绑定IP地址、端口等信息到socket上，用函数bind(); <br>　　4、开启监听，用函数listen()； <br>　　5、接收客户端上来的连接，用函数accept()； <br>　　6、收发数据，用函数send()和recv()，或者read()和write(); <br>　　7、关闭网络连接； <br>　　8、关闭监听； </p><p>TCP编程的客户端一般步骤是： <br>　　1、创建一个socket，用函数socket()； <br>　　2、设置socket属性，用函数setsockopt();* 可选 <br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 <br>　　4、设置要连接的对方的IP地址和端口等属性； <br>　　5、连接服务器，用函数connect()； <br>　　6、收发数据，用函数send()和recv()，或者read()和write(); <br>　　7、关闭网络连接；</p><p>UDP:<br>与之对应的UDP编程步骤要简单许多，分别如下： <br>　　UDP编程的服务器端一般步骤是： <br>　　1、创建一个socket，用函数socket()； <br>　　2、设置socket属性，用函数setsockopt();* 可选 <br>　　3、绑定IP地址、端口等信息到socket上，用函数bind(); <br>　　4、循环接收数据，用函数recvfrom(); <br>　　5、关闭网络连接； </p><p>UDP编程的客户端一般步骤是： <br>　　1、创建一个socket，用函数socket()； <br>　　2、设置socket属性，用函数setsockopt();* 可选 <br>　　3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 <br>　　4、设置对方的IP地址和端口等属性; <br>　　5、发送数据，用函数sendto(); <br>　　6、关闭网络连接；</p><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。</p><p>UDP补充：<br>   UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，UDP也无法进行流量控制等避免网络拥塞的行为。此外，传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。UDP有点类似于用户说什么听什么的机制，但是需要用户充分考虑好上层协议类型并制作相应的应用程序。</p><p>TCP补充：<br>  TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p><p>TCP与UDP区别总结：<br>1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保   证可靠交付<br>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的<br>  UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信<br>5、TCP首部开销20字节;UDP的首部开销小，只有8个字节<br>6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</p>','TCP与UDP基本区别\r\n  1.基于连接与无连接\r\n  2.TCP要求系统资源较多，UDP较少； \r\n  3.UDP程序结构较简单 \r\n  4.流模式（TCP）与数据报模式(UDP); \r\n  5.TCP保证数据正确性，UDP可能丢包 \r\n  6.TCP保证数据顺序，UDP不保证 \r\n　　\r\nUDP应用场景：\r\n  1.面向数据报方式\r\n  2.网络数据大多为短消息 \r\n  3.拥有大量Clie...','TCP,UDP','uploads/article/default.jpg',0,4,'2018-03-18 22:44:37','2018-03-24 03:55:04',NULL),(14,2,'TCP如何实现拥塞控制和流量控制','汤一碗','定义\r\nTCP作为面向连接的提供全双工可靠服务协议，具有差错控制、拥塞控制和流量控制等功能。此处所谓的拥塞控制和流量控制，就是将发送端发送能力、接收端接收信息的能力以及当前的网络环境参与考虑，在网络拥塞情况严重或者接收端接收能力有限的情况下，减缓或暂停消息发送，当情况改善时，增强消息发送能力，加上超时/丢失重发的机制，共同提供可靠传输。\r\n\r\n流量控制\r\n流量控制以动态调整发送空间大小(滑动窗口)的形式来反映接收端接收消息的能力，反馈给发送端以调整发送速度，避免发送速度过快导致的丢包或者过慢降低整体性能。\r\n\r\n这里采用滑动窗口机制，一是不用每次发送完成都需要等待收到确认消息才能继续发送，二是参考接收端的接收能力，限制发送数据段大小，避免丢失现象。\r\n\r\n典型行为如下：\r\n\r\n\r\n\r\n虽然接收端可以将通过ACK确认消息(或者直接发送给发送端消息，TCP连接全双工，报头有seq和ack)，来反馈待接收能力，但是发送端要考虑的却不只是接收端的接收能力，还要考虑网络环境。\r\n\r\n拥塞控制\r\n拥塞控制也就是考虑当前的网络环境，动态调整窗口大小，没有发生拥塞情况，则窗口增大，拥塞了窗口减小，如此往复，最终应该接近与接收端的窗口大小。\r\n\r\n具体的拥塞控制算法如下：\r\n\r\n慢启动和拥塞避免\r\n在开始发送信息时，由于不知道具体的网络环境，为避免大量信息造成的拥塞现象，此时的拥塞窗口以最小值（即拥塞窗口和接收端窗口中的较小值）进行数据发送，并设定门限值作为慢启动算法和拥塞避免算法的分割点。慢启动是指以最小的拥塞窗口按照指数形式递增，达到门限值后，以拥塞避免算法，即线性递增方式增大拥塞窗口（这里递增时间间隔为一个往返时间RTT）。\r\n\r\n在上述过程中，无论是窗口大小指数递增或者线性递增，当发生拥塞现象，则门限值更新为当前窗口大小的一半，拥塞窗口大小变为最小值，重复上述递增过程（此时属于网络环境限制，所以在接收端和拥塞窗口两个限制条件中选择拥塞窗口作为限制）。\r\n\r\n如图所示\r\n\r\n\r\n\r\n快速重发和快速恢复\r\n当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。当收到三个表示同一个数据段的ack时，不需要等待计时器超时，即重新发送数据段（当时这三个ack要在超时之前到达发送端），因为能够收到接收端的ack确认信息，所以数据段只是单纯的丢失，而不是因为网络拥塞导致，所以此时不需要拥塞窗口更新为最小值进行慢启动（如果这样的话，反倒因为拥塞窗口的增长需要时间，可能导致性能降低），此时需要设置拥塞窗口大小为：门限值大小+3，当然此处的门限值已经更新为拥塞窗口值的一半大小，该行为也就是所谓的“乘法减少”，更新之后按照拥塞避免算法继续进行。\r\n\r\n如图所示\r\n\r\n\r\n\r\n总结\r\nTCP协议属于全双工协议，以上所说的发送端同样也是接收端，传输中不仅需要考虑两个端主机的发送接收能力，同样需要考虑网络所处环境。','<p>定义<br>TCP作为面向连接的提供全双工可靠服务协议，具有差错控制、拥塞控制和流量控制等功能。此处所谓的拥塞控制和流量控制，就是将发送端发送能力、接收端接收信息的能力以及当前的网络环境参与考虑，在网络拥塞情况严重或者接收端接收能力有限的情况下，减缓或暂停消息发送，当情况改善时，增强消息发送能力，加上超时/丢失重发的机制，共同提供可靠传输。</p><p>流量控制<br>流量控制以动态调整发送空间大小(滑动窗口)的形式来反映接收端接收消息的能力，反馈给发送端以调整发送速度，避免发送速度过快导致的丢包或者过慢降低整体性能。</p><p>这里采用滑动窗口机制，一是不用每次发送完成都需要等待收到确认消息才能继续发送，二是参考接收端的接收能力，限制发送数据段大小，避免丢失现象。</p><p>典型行为如下：</p><p>虽然接收端可以将通过ACK确认消息(或者直接发送给发送端消息，TCP连接全双工，报头有seq和ack)，来反馈待接收能力，但是发送端要考虑的却不只是接收端的接收能力，还要考虑网络环境。</p><p>拥塞控制<br>拥塞控制也就是考虑当前的网络环境，动态调整窗口大小，没有发生拥塞情况，则窗口增大，拥塞了窗口减小，如此往复，最终应该接近与接收端的窗口大小。</p><p>具体的拥塞控制算法如下：</p><p>慢启动和拥塞避免<br>在开始发送信息时，由于不知道具体的网络环境，为避免大量信息造成的拥塞现象，此时的拥塞窗口以最小值（即拥塞窗口和接收端窗口中的较小值）进行数据发送，并设定门限值作为慢启动算法和拥塞避免算法的分割点。慢启动是指以最小的拥塞窗口按照指数形式递增，达到门限值后，以拥塞避免算法，即线性递增方式增大拥塞窗口（这里递增时间间隔为一个往返时间RTT）。</p><p>在上述过程中，无论是窗口大小指数递增或者线性递增，当发生拥塞现象，则门限值更新为当前窗口大小的一半，拥塞窗口大小变为最小值，重复上述递增过程（此时属于网络环境限制，所以在接收端和拥塞窗口两个限制条件中选择拥塞窗口作为限制）。</p><p>如图所示</p><p>快速重发和快速恢复<br>当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。当收到三个表示同一个数据段的ack时，不需要等待计时器超时，即重新发送数据段（当时这三个ack要在超时之前到达发送端），因为能够收到接收端的ack确认信息，所以数据段只是单纯的丢失，而不是因为网络拥塞导致，所以此时不需要拥塞窗口更新为最小值进行慢启动（如果这样的话，反倒因为拥塞窗口的增长需要时间，可能导致性能降低），此时需要设置拥塞窗口大小为：门限值大小+3，当然此处的门限值已经更新为拥塞窗口值的一半大小，该行为也就是所谓的“乘法减少”，更新之后按照拥塞避免算法继续进行。</p><p>如图所示</p><p>总结<br>TCP协议属于全双工协议，以上所说的发送端同样也是接收端，传输中不仅需要考虑两个端主机的发送接收能力，同样需要考虑网络所处环境。</p>','定义\r\nTCP作为面向连接的提供全双工可靠服务协议，具有差错控制、拥塞控制和流量控制等功能。此处所谓的拥塞控制和流量控制，就是将发送端发送能力、接收端接收信息的能力以及当前的网络环境参与考虑，在网络拥塞情况严重或者接收端接收能力有限的情况下，减缓或暂停消息发送，当情况改善时，增强消息发送能力，加上超时/丢失重发的机制，共同提供可靠传输。\r\n\r\n流量控制\r\n流量控制以动态调整发送空间大小(滑动窗口)...','TCP,拥塞控制','uploads/article/default.jpg',0,3,'2018-03-18 23:02:15','2018-03-21 13:20:45',NULL),(15,2,'HTTP状态码','汤一碗','1开头的http状态码\r\n表示临时响应并需要请求者继续执行操作的状态代码。\r\n\r\n100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \r\n101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\r\n\r\n2开头的http状态码\r\n表示请求成功\r\n\r\n200     成功处理了请求，一般情况下都是返回此状态码； \r\n201     请求成功并且服务器创建了新的资源。 \r\n202     接受请求但没创建资源； \r\n203     返回另一资源的请求； \r\n204     服务器成功处理了请求，但没有返回任何内容；\r\n205     服务器成功处理了请求，但没有返回任何内容；\r\n206     处理部分请求；\r\n\r\n3xx （重定向） \r\n重定向代码，也是常见的代码\r\n\r\n300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 \r\n301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 \r\n302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 \r\n303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 \r\n304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 \r\n305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 \r\n307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。\r\n\r\n\r\n4开头的http状态码表示请求出错\r\n \r\n400    服务器不理解请求的语法。 \r\n401   请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 \r\n403   服务器拒绝请求。 \r\n404   服务器找不到请求的网页。 \r\n405   禁用请求中指定的方法。 \r\n406   无法使用请求的内容特性响应请求的网页。 \r\n407   此状态代码与 401类似，但指定请求者应当授权使用代理。 \r\n408   服务器等候请求时发生超时。 \r\n409   服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 \r\n410   如果请求的资源已永久删除，服务器就会返回此响应。 \r\n411   服务器不接受不含有效内容长度标头字段的请求。 \r\n412   服务器未满足请求者在请求中设置的其中一个前提条件。 \r\n413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 \r\n414   请求的 URI（通常为网址）过长，服务器无法处理。 \r\n415   请求的格式不受请求页面的支持。 \r\n416   如果页面无法提供请求的范围，则服务器会返回此状态代码。 \r\n417   服务器未满足”期望”请求标头字段的要求。\r\n\r\n\r\n5开头状态码并不常见，但是我们应该知道\r\n\r\n500   （服务器内部错误）  服务器遇到错误，无法完成请求。 \r\n501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 \r\n502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 \r\n503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 \r\n504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 \r\n505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。','<p>1开头的http状态码<br>表示临时响应并需要请求者继续执行操作的状态代码。</p><p>100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  <br>101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。</p><p>2开头的http状态码<br>表示请求成功</p><p>200     成功处理了请求，一般情况下都是返回此状态码； <br>201     请求成功并且服务器创建了新的资源。 <br>202     接受请求但没创建资源； <br>203     返回另一资源的请求； <br>204     服务器成功处理了请求，但没有返回任何内容；<br>205     服务器成功处理了请求，但没有返回任何内容；<br>206     处理部分请求；</p><p>3xx （重定向） <br>重定向代码，也是常见的代码</p><p>300   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 <br>301   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 <br>302   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 <br>303   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 <br>304   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 <br>305   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 <br>307   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</p><p>4开头的http状态码表示请求出错</p><p>400    服务器不理解请求的语法。 <br>401   请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 <br>403   服务器拒绝请求。 <br>404   服务器找不到请求的网页。 <br>405   禁用请求中指定的方法。 <br>406   无法使用请求的内容特性响应请求的网页。 <br>407   此状态代码与 401类似，但指定请求者应当授权使用代理。 <br>408   服务器等候请求时发生超时。 <br>409   服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 <br>410   如果请求的资源已永久删除，服务器就会返回此响应。 <br>411   服务器不接受不含有效内容长度标头字段的请求。 <br>412   服务器未满足请求者在请求中设置的其中一个前提条件。 <br>413   服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 <br>414   请求的 URI（通常为网址）过长，服务器无法处理。 <br>415   请求的格式不受请求页面的支持。 <br>416   如果页面无法提供请求的范围，则服务器会返回此状态代码。 <br>417   服务器未满足”期望”请求标头字段的要求。</p><p>5开头状态码并不常见，但是我们应该知道</p><p>500   （服务器内部错误）  服务器遇到错误，无法完成请求。 <br>501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 <br>502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 <br>503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 <br>504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 <br>505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p>','1开头的http状态码\r\n表示临时响应并需要请求者继续执行操作的状态代码。\r\n\r\n100   （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。  \r\n101   （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。\r\n\r\n2开头的http状态码\r\n表示请求成功\r\n\r\n200     成功处理了请求，一般情况下都是返回此状态码； \r\n20...','状态码,HTTP','uploads/article/default.jpg',0,3,'2018-03-18 23:52:52','2018-03-22 22:46:23',NULL),(16,5,'MySQL中MyISAM与InnoDB区别及选择','汤一碗','![20180324](/uploads/article/20180324/5ab5f26aba060.png \"20180324\")\r\nInnoDB：\r\n支持事务处理等\r\n不加锁读取\r\n支持外键\r\n支持行锁\r\n不支持FULLTEXT类型的索引\r\n不保存表的具体行数，扫描表来计算有多少行\r\nDELETE 表时，是一行一行的删除\r\nInnoDB 把数据和索引存放在表空间里面\r\n跨平台可直接拷贝使用\r\nInnoDB中必须包含AUTO_INCREMENT类型字段的索引\r\n表格很难被压缩\r\n\r\nMyISAM：\r\n不支持事务，回滚将造成不完全回滚，不具有原子性\r\n不支持外键\r\n不支持外键\r\n支持全文搜索\r\n保存表的具体行数,不带where时，直接返回保存的行数\r\nDELETE 表时，先drop表，然后重建表\r\nMyISAM 表被存放在三个文件 。frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex)引伸\r\n跨平台很难直接拷贝\r\nMyISAM中可以使AUTO_INCREMENT类型字段建立联合索引\r\n表格可以被压缩\r\n\r\n选择：\r\n因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。\r\n如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。\r\n两种类型都有自己优缺点，选择那个完全要看自己的实际类弄。','<p><img src=\"/uploads/article/20180324/5ab5f26aba060.png\" alt=\"20180324\" title=\"20180324\"><br>InnoDB：<br>支持事务处理等<br>不加锁读取<br>支持外键<br>支持行锁<br>不支持FULLTEXT类型的索引<br>不保存表的具体行数，扫描表来计算有多少行<br>DELETE 表时，是一行一行的删除<br>InnoDB 把数据和索引存放在表空间里面<br>跨平台可直接拷贝使用<br>InnoDB中必须包含AUTO_INCREMENT类型字段的索引<br>表格很难被压缩</p><p>MyISAM：<br>不支持事务，回滚将造成不完全回滚，不具有原子性<br>不支持外键<br>不支持外键<br>支持全文搜索<br>保存表的具体行数,不带where时，直接返回保存的行数<br>DELETE 表时，先drop表，然后重建表<br>MyISAM 表被存放在三个文件 。frm 文件存放表格定义。 数据文件是MYD (MYData) 。 索引文件是MYI (MYIndex)引伸<br>跨平台很难直接拷贝<br>MyISAM中可以使AUTO_INCREMENT类型字段建立联合索引<br>表格可以被压缩</p><p>选择：<br>因为MyISAM相对简单所以在效率上要优于InnoDB.如果系统读多，写少。对原子性要求低。那么MyISAM最好的选择。且MyISAM恢复速度快。可直接用备份覆盖恢复。<br>如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了。<br>两种类型都有自己优缺点，选择那个完全要看自己的实际类弄。</p>','InnoDB：支持事务处理等不加锁读取支持外键支持行锁不支持FULLTEXT类型的索引不保存表的具体行数，扫描表来计算有多少行DELETE 表时，是一行一行的删除InnoDB 把数据和索引存放在表空间里面跨平台可直接拷贝使用InnoDB中必须包含AUTO_INCREMENT类型字段的索引表格很难被压缩MyISAM：不支持事务，回滚将造成不完全...','MySQL','/uploads/article/20180324/5ab5f26aba060.png',0,4,'2018-03-19 00:14:09','2018-03-25 11:43:53',NULL),(17,5,'MySQL的四种事务隔离级别','汤一碗','一、事务的基本要素（ACID）\r\n\r\n　　1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。\r\n\r\n　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。\r\n\r\n　　 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。\r\n\r\n　　 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。\r\n\r\n \r\n\r\n二、事务的并发问题\r\n\r\n　　1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据\r\n\r\n　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。\r\n\r\n　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。\r\n\r\n　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表\r\n\r\n \r\n\r\n三、MySQL事务隔离级别\r\n#Read Uncommitted(读取未提交内容)\r\n\r\n在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。\r\n\r\n#Read Committed(读取提交内容)\r\n\r\n这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。\r\n\r\n#Repeatable Read(可重读)\r\n\r\n这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 (Phantom Read)。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。\r\n\r\n#Serializable(可串行化)\r\n\r\n这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。\r\n\r\n\r\n![事务隔离](/uploads/article/20180319/5aaea4ebe537d.png \"事务隔离\")\r\n**mysql默认的事务隔离级别为repeatable-read**\r\n\r\n　　补充：\r\n\r\n　　1、SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异\r\n\r\n　　2、mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行\r\n\r\n　　3、事务隔离级别为读提交时，写数据只会锁住相应的行\r\n\r\n　　4、事务隔离级别为可重复读时，写数据会锁住整张表\r\n\r\n　　5、事务隔离级别为串行化时，读写数据都会锁住整张表\r\n\r\n　　 6、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。\r\n###参考：\r\n[MySQL的四种事务隔离级别](https://www.cnblogs.com/huanongying/p/7021555.html \"MySQL的四种事务隔离级别\")\r\n[Mysql的四种隔离级别讲解](https://www.2cto.com/database/201711/699102.html \"Mysql的四种隔离级别讲解\")','<p>一、事务的基本要素（ACID）</p><p>　　1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</p><p>　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</p><p>　　 3、隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p>　　 4、持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</p><p>二、事务的并发问题</p><p>　　1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p>　　2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果 不一致。</p><p>　　3、幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p><p>　　小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</p><p>三、MySQL事务隔离级别</p><h1>Read Uncommitted(读取未提交内容)</h1><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。</p><h1>Read Committed(读取提交内容)</h1><p>这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><h1>Repeatable Read(可重读)</h1><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 (Phantom Read)。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。</p><h1>Serializable(可串行化)</h1><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p><p><img src=\"/uploads/article/20180319/5aaea4ebe537d.png\" alt=\"事务隔离\" title=\"事务隔离\"><br><strong>mysql默认的事务隔离级别为repeatable-read</strong></p><p>　　补充：</p><p>　　1、SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p>　　2、mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行</p><p>　　3、事务隔离级别为读提交时，写数据只会锁住相应的行</p><p>　　4、事务隔离级别为可重复读时，写数据会锁住整张表</p><p>　　5、事务隔离级别为串行化时，读写数据都会锁住整张表</p><p>　　 6、隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p><h3>参考：</h3><p><a href=\"https://www.cnblogs.com/huanongying/p/7021555.html\">MySQL的四种事务隔离级别</a><br><a href=\"https://www.2cto.com/database/201711/699102.html\">Mysql的四种隔离级别讲解</a></p>','一、事务的基本要素（ACID）　　1、原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。　　 2、一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 ...','MySQL,事务隔离','/uploads/article/20180319/5aaea4ebe537d.png',0,3,'2018-03-19 01:34:46','2018-03-25 11:43:48',NULL),(18,5,'MySql 创建索引原则','汤一碗','为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。本小节将向读者介绍一些索引的设计原则。\r\n\r\n**大多数MySQL 索引（如PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT 等）在 BTREE 中存\r\n储。只是空间列类型的索引使用 RTREE，并且MEMORY 表还支持 HASH索引**\r\n\r\n1．选择唯一性索引\r\n \r\n唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。\r\n \r\n2．为经常需要排序、分组和联合操作的字段建立索引\r\n \r\n经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。\r\n \r\n3．为常作为查询条件的字段建立索引\r\n \r\n如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。\r\n \r\n4．限制索引的数目\r\n \r\n索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。\r\n \r\n5．尽量使用数据量少的索引\r\n \r\n如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。\r\n \r\n6．尽量使用前缀来索引\r\n \r\n如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。\r\n \r\n7．删除不再使用或者很少使用的索引\r\n \r\n表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。\r\n \r\n注意：选择索引的最终目的是为了使查询的速度变快。上面给出的原则是最基本的准则，但不能拘泥于上面的准则。读者要在以后的学习和工作中进行不断的实践。根据应用的实际情况进行分析和判断，选择最合适的索引方式。','<p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。本小节将向读者介绍一些索引的设计原则。</p><p>**大多数MySQL 索引（如PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT 等）在 BTREE 中存<br>储。只是空间列类型的索引使用 RTREE，并且MEMORY 表还支持 HASH索引**</p><p>1．选择唯一性索引</p><p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。</p><p>2．为经常需要排序、分组和联合操作的字段建立索引</p><p>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</p><p>3．为常作为查询条件的字段建立索引</p><p>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</p><p>4．限制索引的数目</p><p>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</p><p>5．尽量使用数据量少的索引</p><p>如果索引的值很长，那么查询的速度会受到影响。例如，对一个CHAR(100)类型的字段进行全文检索需要的时间肯定要比对CHAR(10)类型的字段需要的时间要多。</p><p>6．尽量使用前缀来索引</p><p>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</p><p>7．删除不再使用或者很少使用的索引</p><p>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</p><p>注意：选择索引的最终目的是为了使查询的速度变快。上面给出的原则是最基本的准则，但不能拘泥于上面的准则。读者要在以后的学习和工作中进行不断的实践。根据应用的实际情况进行分析和判断，选择最合适的索引方式。</p>','为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。本小节将向读者介绍一些索引的设计原则。 1．选择唯一性索引 唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。 2．为经常需要排序...','mysql,索引','uploads/article/default.jpg',0,4,'2018-03-19 01:48:51','2018-03-25 11:59:00',NULL),(19,5,'Mysql索引失效场景','汤一碗','1.WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引\r\n2.类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引\r\n\r\n3.在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用\r\n\r\n4.如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE \'abc%\',MYSQL将使用索引；如果条件是LIKE \'%abc\'，MYSQL将不使用索引。\r\n\r\n5.在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。\r\n\r\n6.如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。\r\n\r\n7.索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER BY 字段，联表字段，一般都是有效的。 建立索引要的就是有效果。 不然还用它干吗？ 如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。\r\n\r\n8.如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引\r\n\r\n9.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引\r\n\r\n10.如果mysql估计使用全表扫描要比使用索引快,则不使用索引','<p>1.WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引<br>2.类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引</p><p>3.在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用</p><p>4.如果WHERE子句的查询条件里使用了比较操作符LIKE和REGEXP，MYSQL只有在搜索模板的第一个字符不是通配符的情况下才能使用索引。比如说，如果查询条件是LIKE \'abc%\',MYSQL将使用索引；如果条件是LIKE \'%abc\'，MYSQL将不使用索引。</p><p>5.在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用。</p><p>6.如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。</p><p>7.索引有用的情况下就太多了。基本只要建立了索引，除了上面提到的索引不会使用的情况下之外，其他情况只要是使用在WHERE条件里，ORDER BY 字段，联表字段，一般都是有效的。 建立索引要的就是有效果。 不然还用它干吗？ 如果不能确定在某个字段上建立的索引是否有效果，只要实际进行测试下比较下执行时间就知道。</p><p>8.如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</p><p>9.如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</p><p>10.如果mysql估计使用全表扫描要比使用索引快,则不使用索引</p>','1.WHERE字句的查询条件里有不等于号（WHERE column!=…），MYSQL将无法使用索引2.类似地，如果WHERE字句的查询条件里使用了函数（如：WHERE DAY(column)=…），MYSQL将无法使用索引3.在JOIN操作中（需要从多个数据表提取数据时），MYSQL只有在主键和外键的数据类型相同时才能使用索引，否则即使建立了索引也不会使用4.如果WHERE子...','mysqkl,索引','uploads/article/default.jpg',0,4,'2018-03-19 01:55:36','2018-03-25 11:43:17',NULL),(20,2,'解决hash冲突的三个方法','汤一碗','通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：\r\n\r\n开放定址法\r\n这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：\r\n\r\nHi=（H（key）+di）% m   i=1，2，…，n\r\n\r\n其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：\r\n\r\n线性探测再散列\r\ndii=1，2，3，…，m-1\r\n\r\n这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。\r\n\r\n二次探测再散列\r\ndi=12，-12，22，-22，…，k2，-k2    ( k<=m/2 )\r\n\r\n这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。\r\n\r\n伪随机探测再散列\r\ndi=伪随机数序列。\r\n\r\n \r\n\r\n具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。\r\n\r\n例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。\r\n\r\n如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。\r\n\r\n如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。\r\n\r\n如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。\r\n\r\n再哈希法\r\n这种方法是同时构造多个不同的哈希函数：\r\n\r\nHi=RH1（key）  i=1，2，…，k\r\n\r\n当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。\r\n\r\n链地址法\r\n这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。\r\n\r\n \r\n\r\n建立公共溢出区\r\n这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。\r\n\r\n \r\n\r\n\r\n优缺点\r\n开放散列（open hashing）/ 拉链法（针对桶链结构）\r\n1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可\r\n \r\n2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作\r\n封闭散列（closed hashing）/ 开放定址法\r\n1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的\r\n \r\n2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。','<p>通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：</p><p>开放定址法<br>这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。这种方法有一个通用的再散列函数形式：</p><p>Hi=（H（key）+di）% m   i=1，2，…，n</p><p>其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：</p><p>线性探测再散列<br>dii=1，2，3，…，m-1</p><p>这种方法的特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</p><p>二次探测再散列<br>di=12，-12，22，-22，…，k2，-k2    ( k&lt;=m/2 )</p><p>这种方法的特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</p><p>伪随机探测再散列<br>di=伪随机数序列。</p><p>具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p><p>例如，已知哈希表长度m=11，哈希函数为：H（key）= key  %  11，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。</p><p>如果用线性探测再散列处理冲突，下一个哈希地址为H1=（3 + 1）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 + 2）% 11 = 5，还是冲突，继续找下一个哈希地址为H3=（3 + 3）% 11 = 6，此时不再冲突，将69填入5号单元。</p><p>如果用二次探测再散列处理冲突，下一个哈希地址为H1=（3 + 12）% 11 = 4，仍然冲突，再找下一个哈希地址为H2=（3 - 12）% 11 = 2，此时不再冲突，将69填入2号单元。</p><p>如果用伪随机探测再散列处理冲突，且伪随机数序列为：2，5，9，……..，则下一个哈希地址为H1=（3 + 2）% 11 = 5，仍然冲突，再找下一个哈希地址为H2=（3 + 5）% 11 = 8，此时不再冲突，将69填入8号单元。</p><p>再哈希法<br>这种方法是同时构造多个不同的哈希函数：</p><p>Hi=RH1（key）  i=1，2，…，k</p><p>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p><p>链地址法<br>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p><p>建立公共溢出区<br>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><p>优缺点<br>开放散列（open hashing）/ 拉链法（针对桶链结构）<br>1）优点： ①对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销） ②由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了 ③删除记录时，比较方便，直接通过指针操作即可</p><p>2）缺点： ①存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销 ②如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数（perfect hash function），此时封闭散列的性能将远高于开放散列 ③由于使用指针，记录不容易进行序列化（serialize）操作<br>封闭散列（closed hashing）/ 开放定址法<br>1）优点： ①记录更容易进行序列化（serialize）操作 ②如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的</p><p>2）缺点： ①存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷 ②使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低 ③由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费 ④删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。</p>','通过构造性能良好的哈希函数，可以减少冲突，但一般不可能完全避免冲突，因此解决冲突是哈希法的另一个关键问题。创建哈希表和查找哈希表都会遇到冲突，两种情况下解决冲突的方法应该一致。下面以创建哈希表为例，说明解决冲突的方法。常用的解决冲突方法有以下四种：\r\n\r\n开放定址法\r\n这种方法也称再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p...','hash','uploads/article/default.jpg',0,3,'2018-03-19 03:40:00','2018-03-22 21:09:14',NULL),(21,2,'收集遇到的面试题(持续更新)','汤一碗','**3.20 小米后端开发：**\r\n1. apach nginx 处理多线程上的不同（细节\r\n2. nginx面对并发怎么进行最优处理\r\n3. redis 除了缓存数据还可以做什么\r\n4. mysql索引是用了什么结构（B+，这种结构的特性是什么\r\n5. 联合索引的作用，实际的用途\r\n6. mysql并发请求时判断冲突进行回滚依靠的是什么\r\n7. mvcc的原理\r\n8. mysql隔离机制，分别可能产生的后果，开发中什么情况下需要加锁，有几种加锁方式\r\n9. nginx的优点和缺点\r\n10. apache的优点和缺点\r\n11. php中弱类型的实现(为什么用union存储不用结构体)，对zend引擎的其他理解','<p><strong>3.20 小米后端开发：</strong></p><ol><li>apach nginx 处理多线程上的不同（细节</li><li>nginx面对并发怎么进行最优处理</li><li>redis 除了缓存数据还可以做什么</li><li>mysql索引是用了什么结构（B+，这种结构的特性是什么</li><li>联合索引的作用，实际的用途</li><li>mysql并发请求时判断冲突进行回滚依靠的是什么</li><li>mvcc的原理</li><li>mysql隔离机制，分别可能产生的后果，开发中什么情况下需要加锁，有几种加锁方式</li><li>nginx的优点和缺点</li><li>apache的优点和缺点</li><li>php中弱类型的实现(为什么用union存储不用结构体)，对zend引擎的其他理解</li></ol>','收集从18年3月份开始遇到过的面试问题，共勉','面试','uploads/article/default.jpg',1,3,'2018-03-22 21:08:57','2018-03-25 14:16:49',NULL),(22,1,'Foreach小技巧（递归实现生成无限级树）','汤一碗','对于二级分类，为了说明方便，我从网上找一个比较好说明的例子，那就是“新闻分类“！\r\n\r\n好了，废话不多说，开始正题！我们先写一个数组。\r\n\r\n//从数据库中取出的分类数据\r\n```c\r\n$original_array = array(\r\n  array(\'id\' => 1,\'pid\' => 0,\'name\' => \'新闻分类\'),\r\n  array(\'id\' => 2,\'pid\' => 0,\'name\' => \'最新公告\'),\r\n  array(\'id\' => 3,\'pid\' => 1,\'name\' => \'国内新闻\'),\r\n  array(\'id\' => 4,\'pid\' => 1,\'name\' => \'国际新闻\'),\r\n  array(\'id\' => 5,\'pid\' => 0,\'name\' => \'图片分类\'),\r\n  array(\'id\' => 6,\'pid\' => 5,\'name\' => \'新闻图片\'),\r\n  array(\'id\' => 7,\'pid\' => 5,\'name\' => \'其它图片\')\r\n);\r\n```\r\n同时，数据库是这个样子的。\r\n![example2018322](https://files.jb51.net/file_images/article/201610/20161025113107096.png?2016925113118 \"example2018322\")\r\n\r\n** 直接使用foreach函数取出来的数组是这个样子的！**\r\n```c\r\n//从数据库中取出的分类数据\r\n$original_array = array(\r\n  array(\r\n    \'id\' => 1,\r\n    \'pid\' => 0,\r\n    \'name\' => \'新闻分类\'\r\n  ),\r\n  array(\r\n    \'id\' => 2,\r\n    \'pid\' => 0,\r\n    \'name\' => \'最新公告\'\r\n  ),\r\n  array(\r\n    \'id\' => 3,\r\n    \'pid\' => 1,\r\n    \'name\' => \'国内新闻\'\r\n  ),\r\n  array(\r\n    \'id\' => 4,\r\n    \'pid\' => 1,\r\n    \'name\' => \'国际新闻\'\r\n  ),\r\n  array(\r\n    \'id\' => 5,\r\n    \'pid\' => 0,\r\n    \'name\' => \'图片分类\'\r\n  ),\r\n  array(\r\n    \'id\' => 6,\r\n    \'pid\' => 5,\r\n    \'name\' => \'新闻图片\'\r\n  ),\r\n  array(\r\n    \'id\' => 7,\r\n    \'pid\' => 5,\r\n    \'name\' => \'其它图片\'\r\n  )\r\n);\r\n```\r\n\r\n**我们最终想要的结果是这样子的！**\r\n```c\r\n//整理后的分类数据\r\n$output_array = array(\r\n  array(\r\n    \'id\' => 1,\r\n    \'pid\' => 0,\r\n    \'name\' => \'新闻分类\',\r\n    \'children\' => array(\r\n      array(\r\n        \'id\' => 3,\r\n        \'pid\' => 1,\r\n        \'name\' => \'国内新闻\'\r\n      ),\r\n      array(\r\n        \'id\' => 4,\r\n        \'pid\' => 1,\r\n        \'name\' => \'国际新闻\'\r\n      ),\r\n    ),\r\n  ),\r\n  array(\r\n    \'id\' => 2,\r\n    \'pid\' => 0,\r\n    \'name\' => \'最新公告\',\r\n  ),\r\n  array(\r\n    \'id\' => 5,\r\n    \'pid\' => 0,\r\n    \'name\' => \'图片分类\',\r\n    \'children\' => array(\r\n      array(\r\n        \'id\' => 6,\r\n        \'pid\' => 5,\r\n        \'name\' => \'新闻图片\'\r\n      ),\r\n      array(\r\n        \'id\' => 7,\r\n        \'pid\' => 5,\r\n        \'name\' => \'其它图片\'\r\n      ),\r\n    ),\r\n  ),\r\n);\r\n```\r\n**这时就要想办法把这个功能实现拉**\r\n**函数如下：**\r\n```c\r\n//整理函数\r\n/**\r\n * 生成无限级树算法\r\n * @author Baiyu 2014-04-01\r\n * @param array $arr        输入数组\r\n * @param number $pid        根级的pid\r\n * @param string $column_name    列名,id|pid父id的名字|children子数组的键名\r\n * @return array $ret\r\n */\r\nfunction make_tree($arr, $pid = 0, $column_name = \'id|pid|children\') {\r\n  list($idname, $pidname, $cldname) = explode(\'|\', $column_name);\r\n  $ret = array();\r\n  foreach ($arr as $k => $v) {\r\n    if ($v [$pidname] == $pid) {\r\n      $tmp = $arr [$k];\r\n      unset($arr [$k]);\r\n      $tmp [$cldname] = make_tree($arr, $v [$idname], $column_name);\r\n      $ret [] = $tmp;\r\n    }\r\n  }\r\n  return $ret;\r\n}\r\n```\r\n那们怎么使用呢？\r\n```c\r\n//整理函数的使用\r\n$output_array = make_tree($original_array);\r\n完整使用方法如下：\r\n\r\n$output_array =make_tree($arr, 0, \'id|pid|children\')\r\n函数之后，我们这样调用就得到了一级分类与二级分类！\r\n\r\nforeach ($output_array as $key => $value) {\r\n  echo \'<h2>\'.$value[\'name\'].\'</h2>\';\r\n  foreach ($value[\'children\'] as $key => $value) {\r\n    echo $value[\'name\'].\',\';\r\n}\r\n```\r\n结果如下：\r\n![example2018322_2](https://files.jb51.net/file_images/article/201610/20161025113303839.png?2016925113315 \"example2018322_2\")\r\n**附：$output_array 这个数组，我们使用print_r，就可以得到如下的结果！**\r\n```c\r\nArray\r\n(\r\n  [0] => Array\r\n    (\r\n      [id] => 1\r\n      [pid] => 0\r\n      [name] => 新闻分类\r\n      [children] => Array\r\n        (\r\n          [0] => Array\r\n            (\r\n              [id] => 3\r\n              [pid] => 1\r\n              [name] => 国内新闻\r\n              [children] => Array\r\n                (\r\n                )\r\n\r\n            )\r\n\r\n          [1] => Array\r\n            (\r\n              [id] => 4\r\n              [pid] => 1\r\n              [name] => 国际新闻\r\n              [children] => Array\r\n                (\r\n                )\r\n\r\n            )\r\n\r\n        )\r\n\r\n    )\r\n\r\n  [1] => Array\r\n    (\r\n      [id] => 2\r\n      [pid] => 0\r\n      [name] => 最新公告\r\n      [children] => Array\r\n        (\r\n        )\r\n\r\n    )\r\n\r\n  [2] => Array\r\n    (\r\n      [id] => 5\r\n      [pid] => 0\r\n      [name] => 图片分类\r\n      [children] => Array\r\n        (\r\n          [0] => Array\r\n            (\r\n              [id] => 6\r\n              [pid] => 5\r\n              [name] => 新闻图片\r\n              [children] => Array\r\n                (\r\n                )\r\n\r\n            )\r\n\r\n          [1] => Array\r\n            (\r\n              [id] => 7\r\n              [pid] => 5\r\n              [name] => 其它图片\r\n              [children] => Array\r\n                (\r\n                )\r\n\r\n            )\r\n\r\n        )\r\n\r\n    )\r\n\r\n)\r\n```','<p>对于二级分类，为了说明方便，我从网上找一个比较好说明的例子，那就是“新闻分类“！</p><p>好了，废话不多说，开始正题！我们先写一个数组。</p><p>//从数据库中取出的分类数据</p><pre><code class=\"lang-c\">$original_array = array(\n  array(\'id\' =&gt; 1,\'pid\' =&gt; 0,\'name\' =&gt; \'新闻分类\'),\n  array(\'id\' =&gt; 2,\'pid\' =&gt; 0,\'name\' =&gt; \'最新公告\'),\n  array(\'id\' =&gt; 3,\'pid\' =&gt; 1,\'name\' =&gt; \'国内新闻\'),\n  array(\'id\' =&gt; 4,\'pid\' =&gt; 1,\'name\' =&gt; \'国际新闻\'),\n  array(\'id\' =&gt; 5,\'pid\' =&gt; 0,\'name\' =&gt; \'图片分类\'),\n  array(\'id\' =&gt; 6,\'pid\' =&gt; 5,\'name\' =&gt; \'新闻图片\'),\n  array(\'id\' =&gt; 7,\'pid\' =&gt; 5,\'name\' =&gt; \'其它图片\')\n);</code></pre><p>同时，数据库是这个样子的。<br><img src=\"https://files.jb51.net/file_images/article/201610/20161025113107096.png?2016925113118\" alt=\"example2018322\" title=\"example2018322\"></p><p><strong> 直接使用foreach函数取出来的数组是这个样子的！</strong></p><pre><code class=\"lang-c\">//从数据库中取出的分类数据\n$original_array = array(\n  array(\n    \'id\' =&gt; 1,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'新闻分类\'\n  ),\n  array(\n    \'id\' =&gt; 2,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'最新公告\'\n  ),\n  array(\n    \'id\' =&gt; 3,\n    \'pid\' =&gt; 1,\n    \'name\' =&gt; \'国内新闻\'\n  ),\n  array(\n    \'id\' =&gt; 4,\n    \'pid\' =&gt; 1,\n    \'name\' =&gt; \'国际新闻\'\n  ),\n  array(\n    \'id\' =&gt; 5,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'图片分类\'\n  ),\n  array(\n    \'id\' =&gt; 6,\n    \'pid\' =&gt; 5,\n    \'name\' =&gt; \'新闻图片\'\n  ),\n  array(\n    \'id\' =&gt; 7,\n    \'pid\' =&gt; 5,\n    \'name\' =&gt; \'其它图片\'\n  )\n);</code></pre><p><strong>我们最终想要的结果是这样子的！</strong></p><pre><code class=\"lang-c\">//整理后的分类数据\n$output_array = array(\n  array(\n    \'id\' =&gt; 1,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'新闻分类\',\n    \'children\' =&gt; array(\n      array(\n        \'id\' =&gt; 3,\n        \'pid\' =&gt; 1,\n        \'name\' =&gt; \'国内新闻\'\n      ),\n      array(\n        \'id\' =&gt; 4,\n        \'pid\' =&gt; 1,\n        \'name\' =&gt; \'国际新闻\'\n      ),\n    ),\n  ),\n  array(\n    \'id\' =&gt; 2,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'最新公告\',\n  ),\n  array(\n    \'id\' =&gt; 5,\n    \'pid\' =&gt; 0,\n    \'name\' =&gt; \'图片分类\',\n    \'children\' =&gt; array(\n      array(\n        \'id\' =&gt; 6,\n        \'pid\' =&gt; 5,\n        \'name\' =&gt; \'新闻图片\'\n      ),\n      array(\n        \'id\' =&gt; 7,\n        \'pid\' =&gt; 5,\n        \'name\' =&gt; \'其它图片\'\n      ),\n    ),\n  ),\n);</code></pre><p><strong>这时就要想办法把这个功能实现拉</strong><br><strong>函数如下：</strong></p><pre><code class=\"lang-c\">//整理函数\n/**\n * 生成无限级树算法\n * @author Baiyu 2014-04-01\n * @param array $arr        输入数组\n * @param number $pid        根级的pid\n * @param string $column_name    列名,id|pid父id的名字|children子数组的键名\n * @return array $ret\n */\nfunction make_tree($arr, $pid = 0, $column_name = \'id|pid|children\') {\n  list($idname, $pidname, $cldname) = explode(\'|\', $column_name);\n  $ret = array();\n  foreach ($arr as $k =&gt; $v) {\n    if ($v [$pidname] == $pid) {\n      $tmp = $arr [$k];\n      unset($arr [$k]);\n      $tmp [$cldname] = make_tree($arr, $v [$idname], $column_name);\n      $ret [] = $tmp;\n    }\n  }\n  return $ret;\n}</code></pre><p>那们怎么使用呢？</p><pre><code class=\"lang-c\">//整理函数的使用\n$output_array = make_tree($original_array);\n完整使用方法如下：\n\n$output_array =make_tree($arr, 0, \'id|pid|children\')\n函数之后，我们这样调用就得到了一级分类与二级分类！\n\nforeach ($output_array as $key =&gt; $value) {\n  echo \'&lt;h2&gt;\'.$value[\'name\'].\'&lt;/h2&gt;\';\n  foreach ($value[\'children\'] as $key =&gt; $value) {\n    echo $value[\'name\'].\',\';\n}</code></pre><p>结果如下：<br><img src=\"https://files.jb51.net/file_images/article/201610/20161025113303839.png?2016925113315\" alt=\"example2018322_2\" title=\"example2018322_2\"><br><strong>附：$output_array 这个数组，我们使用print_r，就可以得到如下的结果！</strong></p><pre><code class=\"lang-c\">Array\n(\n  [0] =&gt; Array\n    (\n      [id] =&gt; 1\n      [pid] =&gt; 0\n      [name] =&gt; 新闻分类\n      [children] =&gt; Array\n        (\n          [0] =&gt; Array\n            (\n              [id] =&gt; 3\n              [pid] =&gt; 1\n              [name] =&gt; 国内新闻\n              [children] =&gt; Array\n                (\n                )\n\n            )\n\n          [1] =&gt; Array\n            (\n              [id] =&gt; 4\n              [pid] =&gt; 1\n              [name] =&gt; 国际新闻\n              [children] =&gt; Array\n                (\n                )\n\n            )\n\n        )\n\n    )\n\n  [1] =&gt; Array\n    (\n      [id] =&gt; 2\n      [pid] =&gt; 0\n      [name] =&gt; 最新公告\n      [children] =&gt; Array\n        (\n        )\n\n    )\n\n  [2] =&gt; Array\n    (\n      [id] =&gt; 5\n      [pid] =&gt; 0\n      [name] =&gt; 图片分类\n      [children] =&gt; Array\n        (\n          [0] =&gt; Array\n            (\n              [id] =&gt; 6\n              [pid] =&gt; 5\n              [name] =&gt; 新闻图片\n              [children] =&gt; Array\n                (\n                )\n\n            )\n\n          [1] =&gt; Array\n            (\n              [id] =&gt; 7\n              [pid] =&gt; 5\n              [name] =&gt; 其它图片\n              [children] =&gt; Array\n                (\n                )\n\n            )\n\n        )\n\n    )\n\n)</code></pre>','处理一些数据时，偶尔会遇到父分类和子分类在一个二维数组中的情况，那自然要想个办法把它俩分层咯','foreach,递归','https://files.jb51.net/file_images/article/201610/20161025113107096.png?2016925113118',0,3,'2018-03-22 23:31:31','2018-03-25 18:04:47',NULL),(23,2,'悲观锁乐观锁理解和应用','汤一碗','# 悲观锁（Pessimistic Lock）\r\n悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。\r\n\r\n这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。\r\n\r\n# 乐观锁（Optimistic Lock）\r\n乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。\r\n\r\n乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：\r\n\r\n```c\r\nSELECT data AS old_data, version AS old_version FROM …;\r\n根据获取的数据进行业务操作，得到new_data和new_version\r\nUPDATE SET data = new_data, version = new_version WHERE version = old_version\r\nif (updated row > 0) {\r\n    // 乐观锁获取成功，操作完成\r\n} else {\r\n    // 乐观锁获取失败，回滚并重试\r\n}\r\n```\r\n乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。好吧，在此唠叨总结下这两个锁：\r\n\r\n**总结**\r\n乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能\r\n\r\n乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方\r\n\r\n3.根据update结果来判断，我们可以在sql2的时候加一个判断条件update table set 库存=xxx where 库存>0，如果返回false，则说明库存不足，并回滚事务。\r\n4.借助文件排他锁，在处理下单请求的时候，用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户\"服务器繁忙\"\r\n\r\n大致代码如下：\r\n阻塞(等待)模式\r\n\r\n```c\r\n<?php\r\n$fp = fopen(\"lock.txt\", \"w+\");\r\nif(flock($fp,LOCK_EX))   //锁定当前指针，，，\r\n{\r\n  //..处理订单\r\n  flock($fp,LOCK_UN);\r\n}\r\nfclose($fp);\r\n?>\r\n```\r\n非阻塞模式\r\n \r\n\r\n```c\r\n<?php\r\n$fp = fopen(\"lock.txt\", \"w+\");\r\nif(flock($fp,LOCK_EX | LOCK_NB))\r\n{\r\n  //..处理订单\r\n  flock($fp,LOCK_UN);\r\n}\r\nelse\r\n{\r\n  echo \"系统繁忙，请稍后再试\";\r\n}\r\n \r\nfclose($fp);\r\n?>\r\n```\r\n5.如果是分布式集群服务器，就需要一个或多个队列服务器 小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。\r\n\r\n6.使用redis锁 product_lock_key 为票锁key 当product_key存在于redis中时，所有用户都可以进入下单流程。 当进入支付流程时，首先往redis存放sadd(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行sadd操作。','<h1>悲观锁（Pessimistic Lock）</h1><p>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p>这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。</p><h1>乐观锁（Optimistic Lock）</h1><p>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：</p><pre><code class=\"lang-c\">SELECT data AS old_data, version AS old_version FROM …;\n根据获取的数据进行业务操作，得到new_data和new_version\nUPDATE SET data = new_data, version = new_version WHERE version = old_version\nif (updated row &gt; 0) {\n    // 乐观锁获取成功，操作完成\n} else {\n    // 乐观锁获取失败，回滚并重试\n}</code></pre><p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。好吧，在此唠叨总结下这两个锁：</p><p><strong>总结</strong><br>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</p><p>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方</p><p>3.根据update结果来判断，我们可以在sql2的时候加一个判断条件update table set 库存=xxx where 库存&gt;0，如果返回false，则说明库存不足，并回滚事务。<br>4.借助文件排他锁，在处理下单请求的时候，用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户\"服务器繁忙\"</p><p>大致代码如下：<br>阻塞(等待)模式</p><pre><code class=\"lang-c\">&lt;?php\n$fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;);\nif(flock($fp,LOCK_EX))   //锁定当前指针，，，\n{\n  //..处理订单\n  flock($fp,LOCK_UN);\n}\nfclose($fp);\n?&gt;</code></pre><p>非阻塞模式</p><pre><code class=\"lang-c\">&lt;?php\n$fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;);\nif(flock($fp,LOCK_EX | LOCK_NB))\n{\n  //..处理订单\n  flock($fp,LOCK_UN);\n}\nelse\n{\n  echo &quot;系统繁忙，请稍后再试&quot;;\n}\n \nfclose($fp);\n?&gt;</code></pre><p>5.如果是分布式集群服务器，就需要一个或多个队列服务器 小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。</p><p>6.使用redis锁 product_lock_key 为票锁key 当product_key存在于redis中时，所有用户都可以进入下单流程。 当进入支付流程时，首先往redis存放sadd(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行sadd操作。</p>',' 悲观锁（Pessimistic Lock）\r\n悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被selec...','mysql,锁,悲观锁,乐观锁','uploads/article/default.jpg',0,1,'2018-03-23 20:29:12','2018-03-24 12:00:13','2018-03-24 12:00:13'),(24,1,'如何处理PHP内存溢出导致的事故','汤一碗','1. 应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&)。\r\n\r\n2. 数据库操作完成后，要马上关闭连接；\r\n\r\n3. 一个对象使用完，要及时调用析构函数（__destruct()）\r\n\r\n4. 用过的变量及时销毁(unset())掉\r\n\r\n5. 可以使用memory_get_usage()函数,获取当前占用内存 根据当前使用的内存来调整程序\r\n\r\n6. unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。(PHP内核的gc垃圾回收机制决定)\r\n\r\n7. 有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存\r\n\r\n8. (PHP变量底层实现是一个_zval_struct结构体,is_ref__gc表示引用计数 is_ref__gc表示是否为引用)','<ol><li>应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&)。</li><li>数据库操作完成后，要马上关闭连接；</li><li>一个对象使用完，要及时调用析构函数（__destruct()）</li><li>用过的变量及时销毁(unset())掉</li><li>可以使用memory_get_usage()函数,获取当前占用内存 根据当前使用的内存来调整程序</li><li>unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。(PHP内核的gc垃圾回收机制决定)</li><li>有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存</li><li>(PHP变量底层实现是一个_zval_struct结构体,is_ref__gc表示引用计数 is_ref__gc表示是否为引用)</li></ol>','1. 应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&)。\r\n\r\n2. 数据库操作完成后，要马上关闭连接；\r\n\r\n3. 一个对象使用完，要及时调用析构函数（__destruct()）\r\n\r\n4. 用过的变量及时销毁(unset())掉\r\n\r\n5. 可以使用memory_get_usage()函数,获取当前占用内存 根据当前使用的内存来调整程序\r\n\r\n6. unset()函数只能...','内存溢出,php','uploads/article/default.jpg',0,1,'2018-03-23 20:42:06','2018-03-23 21:14:48',NULL),(25,3,'Git命令整理','汤一碗','# 一些git常用命令\r\n\r\n## 查看、添加、提交、删除、找回，重置修改文件\r\n\r\ngit help  # 显示command的help\r\n\r\ngit show # 显示某次提交的内容 git show $id\r\n\r\ngit co --  # 抛弃工作区修改\r\n\r\ngit co . # 抛弃工作区修改\r\n\r\ngit add  # 将工作文件修改提交到本地暂存区\r\n\r\ngit add . # 将所有修改过的工作文件提交暂存区\r\n\r\ngit rm  # 从版本库中删除文件\r\n\r\ngit rm  --cached # 从版本库中删除文件，但不删除文件\r\n\r\ngit reset  # 从暂存区恢复到工作文件\r\n\r\ngit reset -- . # 从暂存区恢复到工作文件\r\n\r\ngit reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改\r\n\r\ngit ci  git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am \"some comments\"\r\n\r\ngit ci --amend # 修改最后一次提交记录\r\n\r\ngit revert <$id> # 恢复某次提交的状态，恢复动作本身也创建次提交对象\r\n\r\ngit revert HEAD # 恢复最后一次提交的状态\r\n\r\n## 查看文件diff\r\n\r\ngit diff  # 比较当前文件和暂存区文件差异 git diff\r\n\r\ngit diff  # 比较两次提交之间的差异\r\n\r\ngit diff .. # 在两个分支之间比较\r\n\r\ngit diff --staged # 比较暂存区和版本库差异\r\n\r\ngit diff --cached # 比较暂存区和版本库差异\r\n\r\ngit diff --stat # 仅仅比较统计信息\r\n\r\n## 查看提交记录\r\n\r\ngit log git log  # 查看该文件每次提交记录\r\n\r\ngit log -p  # 查看每次详细修改内容的diff\r\n\r\ngit log -p -2 # 查看最近两次详细修改内容的diff\r\n\r\ngit log --stat #查看提交统计信息\r\n\r\ntig\r\n\r\nMac上可以使用tig代替diff和log，brew install tig\r\n\r\n## Git 本地分支管理\r\n\r\n查看、切换、创建和删除分支\r\n\r\ngit br -r # 查看远程分支\r\n\r\ngit br  # 创建新的分支\r\n\r\ngit br -v # 查看各个分支最后提交信息\r\n\r\ngit br --merged # 查看已经被合并到当前分支的分支\r\n\r\ngit br --no-merged # 查看尚未被合并到当前分支的分支\r\n\r\ngit co  # 切换到某个分支\r\n\r\ngit co -b  # 创建新的分支，并且切换过去\r\n\r\ngit co -b   # 基于branch创建新的new_branch\r\n\r\ngit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除\r\n\r\ngit co $id -b  # 把某次历史提交记录checkout出来，创建成一个分支\r\n\r\ngit br -d  # 删除某个分支\r\n\r\ngit br -D  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)\r\n\r\n## 分支合并和rebase\r\n\r\ngit merge  # 将branch分支合并到当前分支\r\n\r\ngit merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交\r\n\r\ngit rebase master  # 将master rebase到branch，相当于： git co  && git rebase master && git co master && git merge\r\n\r\n## Git补丁管理(方便在多台机器上开发同步时用)\r\n\r\ngit diff > ../sync.patch # 生成补丁\r\n\r\ngit apply ../sync.patch # 打补丁\r\n\r\ngit apply --check ../sync.patch #测试补丁能否成功\r\n\r\n## Git暂存管理\r\n\r\ngit stash # 暂存\r\n\r\ngit stash list # 列所有stash\r\n\r\ngit stash apply # 恢复暂存的内容\r\n\r\ngit stash drop # 删除暂存区\r\n\r\n## Git远程分支管理\r\n\r\ngit pull # 抓取远程仓库所有分支更新并合并到本地\r\n\r\ngit pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并\r\n\r\ngit fetch origin # 抓取远程仓库更新\r\n\r\ngit merge origin/master # 将远程主分支合并到本地当前分支\r\n\r\ngit co --track origin/branch # 跟踪某个远程分支创建相应的本地分支\r\n\r\ngit co -b  origin/ # 基于远程分支创建本地分支，功能同上\r\n\r\ngit push # push所有分支\r\n\r\ngit push origin master # 将本地主分支推到远程主分支\r\n\r\ngit push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)\r\n\r\ngit push origin  # 创建远程分支， origin是远程仓库名\r\n\r\ngit push origin : # 创建远程分支\r\n\r\ngit push origin : #先删除本地分支(git br -d )，然后再push删除远程分支\r\n\r\n## Git远程仓库管理\r\n\r\nGitHub\r\n\r\ngit remote -v # 查看远程服务器地址和仓库名称\r\n\r\ngit remote show origin # 查看远程服务器仓库状态\r\n\r\ngit remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址\r\n\r\ngit remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm  # 删除远程仓库\r\n\r\n## 创建远程仓库\r\n\r\ngit clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库\r\n\r\nscp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上\r\n\r\nmkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库\r\n\r\ngit remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址\r\n\r\ngit push -u origin master # 客户端首次提交\r\n\r\ngit push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track\r\n\r\ngit remote set-head origin master # 设置远程仓库的HEAD指向master分支\r\n\r\n## 也可以命令设置跟踪远程库和本地库\r\n\r\ngit branch --set-upstream master origin/master\r\n\r\ngit branch --set-upstream develop origin/develop\r\n\r\n\r\n参考链接：https://www.jianshu.com/p/918f950fbd58','<h1>一些git常用命令</h1><h2>查看、添加、提交、删除、找回，重置修改文件</h2><p>git help  # 显示command的help</p><p>git show # 显示某次提交的内容 git show $id</p><p>git co --  # 抛弃工作区修改</p><p>git co . # 抛弃工作区修改</p><p>git add  # 将工作文件修改提交到本地暂存区</p><p>git add . # 将所有修改过的工作文件提交暂存区</p><p>git rm  # 从版本库中删除文件</p><p>git rm  --cached # 从版本库中删除文件，但不删除文件</p><p>git reset  # 从暂存区恢复到工作文件</p><p>git reset -- . # 从暂存区恢复到工作文件</p><p>git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</p><p>git ci  git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　git ci -am \"some comments\"</p><p>git ci --amend # 修改最后一次提交记录</p><p>git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</p><p>git revert HEAD # 恢复最后一次提交的状态</p><h2>查看文件diff</h2><p>git diff  # 比较当前文件和暂存区文件差异 git diff</p><p>git diff  # 比较两次提交之间的差异</p><p>git diff .. # 在两个分支之间比较</p><p>git diff --staged # 比较暂存区和版本库差异</p><p>git diff --cached # 比较暂存区和版本库差异</p><p>git diff --stat # 仅仅比较统计信息</p><h2>查看提交记录</h2><p>git log git log  # 查看该文件每次提交记录</p><p>git log -p  # 查看每次详细修改内容的diff</p><p>git log -p -2 # 查看最近两次详细修改内容的diff</p><p>git log --stat #查看提交统计信息</p><p>tig</p><p>Mac上可以使用tig代替diff和log，brew install tig</p><h2>Git 本地分支管理</h2><p>查看、切换、创建和删除分支</p><p>git br -r # 查看远程分支</p><p>git br  # 创建新的分支</p><p>git br -v # 查看各个分支最后提交信息</p><p>git br --merged # 查看已经被合并到当前分支的分支</p><p>git br --no-merged # 查看尚未被合并到当前分支的分支</p><p>git co  # 切换到某个分支</p><p>git co -b  # 创建新的分支，并且切换过去</p><p>git co -b   # 基于branch创建新的new_branch</p><p>git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</p><p>git co $id -b  # 把某次历史提交记录checkout出来，创建成一个分支</p><p>git br -d  # 删除某个分支</p><p>git br -D  # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</p><h2>分支合并和rebase</h2><p>git merge  # 将branch分支合并到当前分支</p><p>git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</p><p>git rebase master  # 将master rebase到branch，相当于： git co  && git rebase master && git co master && git merge</p><h2>Git补丁管理(方便在多台机器上开发同步时用)</h2><p>git diff &gt; ../sync.patch # 生成补丁</p><p>git apply ../sync.patch # 打补丁</p><p>git apply --check ../sync.patch #测试补丁能否成功</p><h2>Git暂存管理</h2><p>git stash # 暂存</p><p>git stash list # 列所有stash</p><p>git stash apply # 恢复暂存的内容</p><p>git stash drop # 删除暂存区</p><h2>Git远程分支管理</h2><p>git pull # 抓取远程仓库所有分支更新并合并到本地</p><p>git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</p><p>git fetch origin # 抓取远程仓库更新</p><p>git merge origin/master # 将远程主分支合并到本地当前分支</p><p>git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支</p><p>git co -b  origin/ # 基于远程分支创建本地分支，功能同上</p><p>git push # push所有分支</p><p>git push origin master # 将本地主分支推到远程主分支</p><p>git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</p><p>git push origin  # 创建远程分支， origin是远程仓库名</p><p>git push origin : # 创建远程分支</p><p>git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支</p><h2>Git远程仓库管理</h2><p>GitHub</p><p>git remote -v # 查看远程服务器地址和仓库名称</p><p>git remote show origin # 查看远程服务器仓库状态</p><p>git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址</p><p>git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm  # 删除远程仓库</p><h2>创建远程仓库</h2><p>git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</p><p>scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</p><p>mkdir robbin_site.git && cd robbin_site.git && git --bare init # 在服务器创建纯仓库</p><p>git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址</p><p>git push -u origin master # 客户端首次提交</p><p>git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</p><p>git remote set-head origin master # 设置远程仓库的HEAD指向master分支</p><h2>也可以命令设置跟踪远程库和本地库</h2><p>git branch --set-upstream master origin/master</p><p>git branch --set-upstream develop origin/develop</p><p>参考链接：<a href=\"https://www.jianshu.com/p/918f950fbd58\">https://www.jianshu.com/p/918f950fbd58</a></p>','一些git常用命令 查看、添加、提交、删除、找回，重置修改文件git help   显示command的helpgit show  显示某次提交的内容 git show $idgit co    抛弃工作区修改git co .  抛弃工作区修改git add   将工作文件修改提交到本地暂存区git add .  将所有修改过的工作文件提交...','Git,git','uploads/article/default.jpg',0,2,'2018-03-23 21:08:37','2018-03-25 17:42:16',NULL),(26,1,'PHP处理高并发的一些思路(转载','汤一碗','涉及抢购、秒杀、抽奖、抢票等活动时，为了避免超卖,那么库存数量是有限的，但是如果同时下单人数超过了库存数量，就会导致商品超卖问题。那么我们怎么来解决这个问题呢，我的思路如下(伪代码)： \r\n\r\nsql1:查询商品库存\r\nif(库存数量 > 0)\r\n{\r\n  //生成订单...\r\n  sql2:同时库存-1\r\n}\r\n\r\n当没有并发时，上面的流程看起来是再正常不过了，假设同时两个人下单，而库存只有1个了，在sql1阶段两个人查询到的库存都是>0的，于是最终都执行了sql2，库存最后变为-1，超售了，这不是我们想要的结果吧。\r\n\r\n解决这个问题比较流行的思路我总结了下：\r\n**1.用额外的单进程处理一个队列，下单请求放到队列里，一个个处理，就不会有并发的问题了，但是要额外的开启后台进程以及延迟问题，这里暂不予考虑。这里我可使用消息队列，我们常用到Memcacheq、Radis。 比如：有100张票可供用户抢，那么就可以把这100张票放到缓存中，读写时不要加锁。 当并发量大的时候，可能有500人左右抢票成功，这样对于500后面的请求可以直接转到活动结束的静态页面。进去的500个人中有400个人是不可能获得商品的。所以可以根据进入队列的先后顺序只能前100个人购买成功。后面400个人就直接转到活动结束页面。当然进去500个人只是举个例子，至于多少可以自己调整。而活动结束页面一定要用静态页面，不要用数据库。这样就减轻了数据库的压力。\r\n\r\n**2.mysql乐观锁，意思是比如总库存是2,抢购事件提交时，立马将库存+1，那么此时库存是3，然后订单生成后，在更新库存前再查询一次库存(因为订单生成理所当然库存-1，但是先不急，再查一次库存返回结果是3)，看看跟预期的库存数量(这里预期的库存是3)是否保持一致，不一致就回滚，提示用户库存不足。这里说道悲观锁，可能有朋友会问，那一定有乐观锁了吧??这里我就浅谈下我所了解的悲观与乐观锁了**\r\n\r\n悲观锁与乐观锁是两种常见的资源并发锁设计思路，也是并发编程中一个非常基础的概念。本文将对这两种常见的锁机制在数据库数据上的实现进行比较系统的介绍。\r\n\r\n悲观锁（Pessimistic Lock）\r\n悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。\r\n\r\n这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。\r\n\r\n乐观锁（Optimistic Lock）\r\n乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。\r\n\r\n乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：\r\n\r\n```c\r\nSELECT data AS old_data, version AS old_version FROM …;\r\n根据获取的数据进行业务操作，得到new_data和new_version\r\nUPDATE SET data = new_data, version = new_version WHERE version = old_version\r\nif (updated row > 0) {\r\n    // 乐观锁获取成功，操作完成\r\n} else {\r\n    // 乐观锁获取失败，回滚并重试\r\n}\r\n```\r\n乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。好吧，在此唠叨总结下这两个锁：\r\n\r\n总结\r\n乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能\r\n\r\n乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方\r\n\r\n**3.根据update结果来判断，我们可以在sql2的时候加一个判断条件update table set 库存=xxx where 库存>0，如果返回false，则说明库存不足，并回滚事务。\r\n4.借助文件排他锁，在处理下单请求的时候，用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户\"服务器繁忙\"**\r\n\r\n大致代码如下：\r\n阻塞(等待)模式\r\n\r\n```c\r\n<?php\r\n$fp = fopen(\"lock.txt\", \"w+\");\r\nif(flock($fp,LOCK_EX))   //锁定当前指针，，，\r\n{\r\n  //..处理订单\r\n  flock($fp,LOCK_UN);\r\n}\r\nfclose($fp);\r\n?>\r\n```\r\n非阻塞模式\r\n \r\n\r\n```c\r\n<?php\r\n$fp = fopen(\"lock.txt\", \"w+\");\r\nif(flock($fp,LOCK_EX | LOCK_NB))\r\n{\r\n  //..处理订单\r\n  flock($fp,LOCK_UN);\r\n}\r\nelse\r\n{\r\n  echo \"系统繁忙，请稍后再试\";\r\n}\r\n \r\nfclose($fp);\r\n?>\r\n```\r\n**5.如果是分布式集群服务器，就需要一个或多个队列服务器 小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。\r\n6.使用redis锁 product_lock_key 为票锁key 当product_key存在于redis中时，所有用户都可以进入下单流程。 当进入支付流程时，首先往redis存放sadd(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行sadd操作。**\r\n\r\n## 参考\r\n[PHP解决高并发的思路](http://www.cnblogs.com/phpper/p/6716248.html \"PHP解决高并发的思路\")[PHP解决高并发的思路](http://www.cnblogs.com/phpper/p/6716248.html \"PHP解决高并发的思路\")','<p>涉及抢购、秒杀、抽奖、抢票等活动时，为了避免超卖,那么库存数量是有限的，但是如果同时下单人数超过了库存数量，就会导致商品超卖问题。那么我们怎么来解决这个问题呢，我的思路如下(伪代码)： </p><p>sql1:查询商品库存<br>if(库存数量 &gt; 0)<br>{<br>  //生成订单...<br>  sql2:同时库存-1<br>}</p><p>当没有并发时，上面的流程看起来是再正常不过了，假设同时两个人下单，而库存只有1个了，在sql1阶段两个人查询到的库存都是&gt;0的，于是最终都执行了sql2，库存最后变为-1，超售了，这不是我们想要的结果吧。</p><p>解决这个问题比较流行的思路我总结了下：<br>**1.用额外的单进程处理一个队列，下单请求放到队列里，一个个处理，就不会有并发的问题了，但是要额外的开启后台进程以及延迟问题，这里暂不予考虑。这里我可使用消息队列，我们常用到Memcacheq、Radis。 比如：有100张票可供用户抢，那么就可以把这100张票放到缓存中，读写时不要加锁。 当并发量大的时候，可能有500人左右抢票成功，这样对于500后面的请求可以直接转到活动结束的静态页面。进去的500个人中有400个人是不可能获得商品的。所以可以根据进入队列的先后顺序只能前100个人购买成功。后面400个人就直接转到活动结束页面。当然进去500个人只是举个例子，至于多少可以自己调整。而活动结束页面一定要用静态页面，不要用数据库。这样就减轻了数据库的压力。</p><p><strong>2.mysql乐观锁，意思是比如总库存是2,抢购事件提交时，立马将库存+1，那么此时库存是3，然后订单生成后，在更新库存前再查询一次库存(因为订单生成理所当然库存-1，但是先不急，再查一次库存返回结果是3)，看看跟预期的库存数量(这里预期的库存是3)是否保持一致，不一致就回滚，提示用户库存不足。这里说道悲观锁，可能有朋友会问，那一定有乐观锁了吧??这里我就浅谈下我所了解的悲观与乐观锁了</strong></p><p>悲观锁与乐观锁是两种常见的资源并发锁设计思路，也是并发编程中一个非常基础的概念。本文将对这两种常见的锁机制在数据库数据上的实现进行比较系统的介绍。</p><p>悲观锁（Pessimistic Lock）<br>悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p>这里需要注意的一点是不同的数据库对select for update的实现和支持都是有所区别的，例如oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，mysql就没有no wait这个选项。另外mysql还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在mysql中用悲观锁务必要确定走了索引，而不是全表扫描。</p><p>乐观锁（Optimistic Lock）<br>乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。</p><p>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，然后按照如下方式实现：</p><pre><code class=\"lang-c\">SELECT data AS old_data, version AS old_version FROM …;\n根据获取的数据进行业务操作，得到new_data和new_version\nUPDATE SET data = new_data, version = new_version WHERE version = old_version\nif (updated row &gt; 0) {\n    // 乐观锁获取成功，操作完成\n} else {\n    // 乐观锁获取失败，回滚并重试\n}</code></pre><p>乐观锁是否在事务中其实都是无所谓的，其底层机制是这样：在数据库内部update同一行的时候是不允许并发的，即数据库每次执行一条update语句时会获取被update行的写锁，直到这一行被成功更新后才释放。因此在业务操作进行前获取需要锁的数据的当前版本号，然后实际更新数据时再次对比版本号确认与之前获取的相同，并更新版本号，即可确认这之间没有发生并发的修改。如果更新失败即可认为老版本的数据已经被并发修改掉而不存在了，此时认为获取锁失败，需要回滚整个业务操作并可根据需要重试整个过程。好吧，在此唠叨总结下这两个锁：</p><p>总结<br>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</p><p>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方</p><p>**3.根据update结果来判断，我们可以在sql2的时候加一个判断条件update table set 库存=xxx where 库存&gt;0，如果返回false，则说明库存不足，并回滚事务。<br>4.借助文件排他锁，在处理下单请求的时候，用flock锁定一个文件，如果锁定失败说明有其他订单正在处理，此时要么等待要么直接提示用户\"服务器繁忙\"**</p><p>大致代码如下：<br>阻塞(等待)模式</p><pre><code class=\"lang-c\">&lt;?php\n$fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;);\nif(flock($fp,LOCK_EX))   //锁定当前指针，，，\n{\n  //..处理订单\n  flock($fp,LOCK_UN);\n}\nfclose($fp);\n?&gt;</code></pre><p>非阻塞模式</p><pre><code class=\"lang-c\">&lt;?php\n$fp = fopen(&quot;lock.txt&quot;, &quot;w+&quot;);\nif(flock($fp,LOCK_EX | LOCK_NB))\n{\n  //..处理订单\n  flock($fp,LOCK_UN);\n}\nelse\n{\n  echo &quot;系统繁忙，请稍后再试&quot;;\n}\n \nfclose($fp);\n?&gt;</code></pre><p>**5.如果是分布式集群服务器，就需要一个或多个队列服务器 小米和淘宝的抢购还是有稍许不同的，小米重在抢的那瞬间，抢到了名额，就是你的，你就可以下单结算。而淘宝则重在付款的时候的过滤，做了多层过滤，比如要卖10件商品，他会让大于10的用户抢到，在付款的时候再进行并发过滤，一层层的减少一瞬间的并发量。<br>6.使用redis锁 product_lock_key 为票锁key 当product_key存在于redis中时，所有用户都可以进入下单流程。 当进入支付流程时，首先往redis存放sadd(product_lock_key, “1″),如果返回成功，进入支付流程。如果不成，则说明已经有人进入支付流程，则线程等待N秒，递归执行sadd操作。**</p><h2>参考</h2><p><a href=\"http://www.cnblogs.com/phpper/p/6716248.html\">PHP解决高并发的思路</a><a href=\"http://www.cnblogs.com/phpper/p/6716248.html\">PHP解决高并发的思路</a></p>','涉及抢购、秒杀、抽奖、抢票等活动时，为了避免超卖,那么库存数量是有限的，但是如果同时下单人数超过了库存数量，就会导致商品超卖问题。那么我们怎么来解决这个问题呢，我的思路如下(伪代码)： sql1:查询商品库存if(库存数量  0){  //生成订单...  sql2:同时库存1}当没有并发时，上面的流程看起来是再正常不过了，假设同时两个人下单，而库存只有1个了，...','高并发,抢票','uploads/article/default.jpg',0,2,'2018-03-24 12:00:04','2018-03-25 12:47:28',NULL),(27,4,'「七天自制PHP框架」','汤一碗','# 「七天自制PHP框架」\r\n[http://www.cnblogs.com/sweng/p/6624827.html](http://www.cnblogs.com/sweng/p/6624827.html)','<h1>「七天自制PHP框架」</h1><p><a href=\"http://www.cnblogs.com/sweng/p/6624827.html\">http://www.cnblogs.com/sweng/p/6624827.html</a></p>',' 「七天自制PHP框架」\r\n','PHP,学习框架,框架','uploads/article/default.jpg',0,2,'2018-03-24 12:11:25','2018-03-25 13:54:51',NULL),(28,1,'一些PHP的冷知识','汤一碗','1, 尽量不要使用@来进行抑制错误，效率很低\r\n\r\n2，能使用单引号时不要使用双引号\r\n\r\n3，echo的效率比print要高，同时echo可以输出多个变量\r\n\r\n4，使用include，require时候最好使用绝对路径\r\n\r\n5，如果你想知道脚本开始执行（译注：即服务器端收到客户端请求）的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()。\r\n\r\n6，打开apache的mod_deflate模块，可以提高网页的浏览速度。\r\n\r\n7，除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。\r\n\r\n8，调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。','<p>1, 尽量不要使用@来进行抑制错误，效率很低</p><p>2，能使用单引号时不要使用双引号</p><p>3，echo的效率比print要高，同时echo可以输出多个变量</p><p>4，使用include，require时候最好使用绝对路径</p><p>5，如果你想知道脚本开始执行（译注：即服务器端收到客户端请求）的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()。</p><p>6，打开apache的mod_deflate模块，可以提高网页的浏览速度。</p><p>7，除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。</p><p>8，调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。</p>','1, 尽量不要使用@来进行抑制错误，效率很低\r\n\r\n2，能使用单引号时不要使用双引号\r\n\r\n3，echo的效率比print要高，同时echo可以输出多个变量\r\n\r\n4，使用include，require时候最好使用绝对路径\r\n\r\n5，如果你想知道脚本开始执行（译注：即服务器端收到客户端请求）的时刻，使用$_SERVER要好于time()。\r\n\r\n6，打开apache的mod_deflate模块，可...','PHP,小知识','uploads/article/default.jpg',0,2,'2018-03-24 12:44:00','2018-03-25 13:09:51',NULL),(29,4,'php web开发安全之csrf攻击的简单演示和防范','汤一碗','# php web开发安全之csrf攻击的简单演示和防范\r\n[http://www.cnblogs.com/yangtoude/p/php-web-csrf.html](http://www.cnblogs.com/yangtoude/p/php-web-csrf.html)','<h1>php web开发安全之csrf攻击的简单演示和防范</h1><p><a href=\"http://www.cnblogs.com/yangtoude/p/php-web-csrf.html\">http://www.cnblogs.com/yangtoude/p/php-web-csrf.html</a></p>',' php web开发安全之csrf攻击的简单演示和防范\r\n','安全,php','uploads/article/default.jpg',0,2,'2018-03-24 12:56:21','2018-03-25 21:04:46',NULL),(30,1,'php四种基础算法：冒泡，选择，插入和快速排序法','汤一碗','## 需求：分别用 冒泡排序法，快速排序法，选择排序法，插入排序法将下面数组中 的值按照从小到的顺序进行排序。 \r\n$arr(1,43,54,62,21,66,32,78,36,76,39);\r\n\r\n1. 冒泡排序法 \r\n *     思路分析：法如其名，就是像冒泡一样，每次从数组当中 冒一个最大的数出来。 \r\n *     比如：2,4,1    // 第一次 冒出的泡是4 \r\n *                2,1,4   // 第二次 冒出的泡是 2 \r\n *                1,2,4   // 最后就变成这样 \r\n\r\n \r\n```php\r\n$arr=array(1,43,54,62,21,66,32,78,36,76,39);  \r\nfunction getpao($arr)\r\n{  \r\n  $len=count($arr);\r\n  //设置一个空数组 用来接收冒出来的泡\r\n  //该层循环控制 需要冒泡的轮数\r\n  for($i=1;$i<$len;$i++)\r\n  { //该层循环用来控制每轮 冒出一个数 需要比较的次数\r\n    for($k=0;$k<$len-$i;$k++)\r\n    {\r\n       if($arr[$k]>$arr[$k+1])\r\n        {\r\n            $tmp=$arr[$k+1];\r\n            $arr[$k+1]=$arr[$k];\r\n            $arr[$k]=$tmp;\r\n        }\r\n    }\r\n  }\r\n  return $arr;\r\n} \r\n```\r\n2. 选择排序法： \r\n\r\n选择排序法思路： 每次选择一个相应的元素，然后将其放到指定的位置\r\n```php\r\nfunction select_sort($arr) {\r\n//实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数\r\n    //$i 当前最小值的位置， 需要参与比较的元素\r\n    for($i=0, $len=count($arr); $i<$len-1; $i++) {\r\n        //先假设最小的值的位置\r\n        $p = $i;\r\n        //$j 当前都需要和哪些元素比较，$i 后边的。\r\n        for($j=$i+1; $j<$len; $j++) {\r\n            //$arr[$p] 是 当前已知的最小值\r\n            if($arr[$p] > $arr[$j]) {\r\n     //比较，发现更小的,记录下最小值的位置；并且在下次比较时，\r\n // 应该采用已知的最小值进行比较。\r\n                $p = $j;\r\n            }\r\n        }\r\n        //已经确定了当前的最小值的位置，保存到$p中。\r\n //如果发现 最小值的位置与当前假设的位置$i不同，则位置互换即可\r\n        if($p != $i) {\r\n            $tmp = $arr[$p];\r\n            $arr[$p] = $arr[$i];\r\n            $arr[$i] = $tmp;\r\n        }\r\n    }\r\n    //返回最终结果\r\n    return $arr;\r\n}\r\n```\r\n3.插入排序法 \r\n\r\n插入排序法思路：将要排序的元素插入到已经 假定排序号的数组的指定位置。\r\n```php\r\nfunction insert_sort($arr) {\r\n    //区分 哪部分是已经排序好的\r\n    //哪部分是没有排序的\r\n    //找到其中一个需要排序的元素\r\n    //这个元素 就是从第二个元素开始，到最后一个元素都是这个需要排序的元素\r\n    //利用循环就可以标志出来\r\n    //i循环控制 每次需要插入的元素，一旦需要插入的元素控制好了，\r\n    //间接已经将数组分成了2部分，下标小于当前的（左边的），是排序好的序列\r\n    for($i=1, $len=count($arr); $i<$len; $i++) {\r\n        //获得当前需要比较的元素值。\r\n        $tmp = $arr[$i];\r\n        //内层循环控制 比较 并 插入\r\n        for($j=$i-1;$j>=0;$j--) {\r\n   //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素\r\n            if($tmp < $arr[$j]) {\r\n                //发现插入的元素要小，交换位置\r\n                //将后边的元素与前面的元素互换\r\n                $arr[$j+1] = $arr[$j];\r\n                //将前面的数设置为 当前需要交换的数\r\n                $arr[$j] = $tmp;\r\n            } else {\r\n                //如果碰到不需要移动的元素\r\n           //由于是已经排序好是数组，则前面的就不需要再次比较了。\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    //将这个元素 插入到已经排序好的序列内。\r\n    //返回\r\n    return $arr;\r\n}\r\n```\r\n4.快速排序法  \r\n```php\r\nfunction quick_sort($arr) {\r\n    //先判断是否需要继续进行\r\n    $length = count($arr);\r\n    if($length <= 1) {\r\n        return $arr;\r\n    }\r\n    //如果没有返回，说明数组内的元素个数 多余1个，需要排序\r\n    //选择一个标尺\r\n    //选择第一个元素\r\n    $base_num = $arr[0];\r\n    //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内\r\n    //初始化两个数组\r\n    $left_array = array();//小于标尺的\r\n    $right_array = array();//大于标尺的\r\n    for($i=1; $i<$length; $i++) {\r\n        if($base_num > $arr[$i]) {\r\n            //放入左边数组\r\n            $left_array[] = $arr[$i];\r\n        } else {\r\n            //放入右边\r\n            $right_array[] = $arr[$i];\r\n        }\r\n    }\r\n    //再分别对 左边 和 右边的数组进行相同的排序处理方式\r\n    //递归调用这个函数,并记录结果\r\n    $left_array = quick_sort($left_array);\r\n    $right_array = quick_sort($right_array);\r\n    //合并左边 标尺 右边\r\n    return array_merge($left_array, array($base_num), $right_array);\r\n}\r\n```','<h2>需求：分别用 冒泡排序法，快速排序法，选择排序法，插入排序法将下面数组中 的值按照从小到的顺序进行排序。</h2><p>$arr(1,43,54,62,21,66,32,78,36,76,39);</p><ol><li><p>冒泡排序法</p><ul><li>思路分析：法如其名，就是像冒泡一样，每次从数组当中 冒一个最大的数出来。</li><li>比如：2,4,1    // 第一次 冒出的泡是4</li><li>2,1,4   // 第二次 冒出的泡是 2</li><li>1,2,4   // 最后就变成这样</li></ul></li></ol><pre><code class=\"lang-php\">$arr=array(1,43,54,62,21,66,32,78,36,76,39);  \nfunction getpao($arr)\n{  \n  $len=count($arr);\n  //设置一个空数组 用来接收冒出来的泡\n  //该层循环控制 需要冒泡的轮数\n  for($i=1;$i&lt;$len;$i++)\n  { //该层循环用来控制每轮 冒出一个数 需要比较的次数\n    for($k=0;$k&lt;$len-$i;$k++)\n    {\n       if($arr[$k]&gt;$arr[$k+1])\n        {\n            $tmp=$arr[$k+1];\n            $arr[$k+1]=$arr[$k];\n            $arr[$k]=$tmp;\n        }\n    }\n  }\n  return $arr;\n} </code></pre><ol><li>选择排序法：</li></ol><p>选择排序法思路： 每次选择一个相应的元素，然后将其放到指定的位置</p><pre><code class=\"lang-php\">function select_sort($arr) {\n//实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数\n    //$i 当前最小值的位置， 需要参与比较的元素\n    for($i=0, $len=count($arr); $i&lt;$len-1; $i++) {\n        //先假设最小的值的位置\n        $p = $i;\n        //$j 当前都需要和哪些元素比较，$i 后边的。\n        for($j=$i+1; $j&lt;$len; $j++) {\n            //$arr[$p] 是 当前已知的最小值\n            if($arr[$p] &gt; $arr[$j]) {\n     //比较，发现更小的,记录下最小值的位置；并且在下次比较时，\n // 应该采用已知的最小值进行比较。\n                $p = $j;\n            }\n        }\n        //已经确定了当前的最小值的位置，保存到$p中。\n //如果发现 最小值的位置与当前假设的位置$i不同，则位置互换即可\n        if($p != $i) {\n            $tmp = $arr[$p];\n            $arr[$p] = $arr[$i];\n            $arr[$i] = $tmp;\n        }\n    }\n    //返回最终结果\n    return $arr;\n}</code></pre><p>3.插入排序法 </p><p>插入排序法思路：将要排序的元素插入到已经 假定排序号的数组的指定位置。</p><pre><code class=\"lang-php\">function insert_sort($arr) {\n    //区分 哪部分是已经排序好的\n    //哪部分是没有排序的\n    //找到其中一个需要排序的元素\n    //这个元素 就是从第二个元素开始，到最后一个元素都是这个需要排序的元素\n    //利用循环就可以标志出来\n    //i循环控制 每次需要插入的元素，一旦需要插入的元素控制好了，\n    //间接已经将数组分成了2部分，下标小于当前的（左边的），是排序好的序列\n    for($i=1, $len=count($arr); $i&lt;$len; $i++) {\n        //获得当前需要比较的元素值。\n        $tmp = $arr[$i];\n        //内层循环控制 比较 并 插入\n        for($j=$i-1;$j&gt;=0;$j--) {\n   //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素\n            if($tmp &lt; $arr[$j]) {\n                //发现插入的元素要小，交换位置\n                //将后边的元素与前面的元素互换\n                $arr[$j+1] = $arr[$j];\n                //将前面的数设置为 当前需要交换的数\n                $arr[$j] = $tmp;\n            } else {\n                //如果碰到不需要移动的元素\n           //由于是已经排序好是数组，则前面的就不需要再次比较了。\n                break;\n            }\n        }\n    }\n    //将这个元素 插入到已经排序好的序列内。\n    //返回\n    return $arr;\n}</code></pre><p>4.快速排序法</p><pre><code class=\"lang-php\">function quick_sort($arr) {\n    //先判断是否需要继续进行\n    $length = count($arr);\n    if($length &lt;= 1) {\n        return $arr;\n    }\n    //如果没有返回，说明数组内的元素个数 多余1个，需要排序\n    //选择一个标尺\n    //选择第一个元素\n    $base_num = $arr[0];\n    //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内\n    //初始化两个数组\n    $left_array = array();//小于标尺的\n    $right_array = array();//大于标尺的\n    for($i=1; $i&lt;$length; $i++) {\n        if($base_num &gt; $arr[$i]) {\n            //放入左边数组\n            $left_array[] = $arr[$i];\n        } else {\n            //放入右边\n            $right_array[] = $arr[$i];\n        }\n    }\n    //再分别对 左边 和 右边的数组进行相同的排序处理方式\n    //递归调用这个函数,并记录结果\n    $left_array = quick_sort($left_array);\n    $right_array = quick_sort($right_array);\n    //合并左边 标尺 右边\n    return array_merge($left_array, array($base_num), $right_array);\n}</code></pre>',' 需求：分别用 冒泡排序法，快速排序法，选择排序法，插入排序法将下面数组中 的值按照从小到的顺序进行排序。 \r\n$arr(1,43,54,62,21,66,32,78,36,76,39);\r\n\r\n1. 冒泡排序法 \r\n      思路分析：法如其名，就是像冒泡一样，每次从数组当中 冒一个最大的数出来。 \r\n      比如：2,4,1    // 第一次 冒出的泡是4 \r\n            ...','算法,冒泡,快排','uploads/article/default.jpg',0,1,'2018-03-24 15:35:08','2018-03-25 17:36:49',NULL),(31,5,'Mysql冷知识总结','汤一碗','### 几种引擎对比\r\n![20180324_5](/uploads/article/20180324/5ab65dd5b8645.png \"20180324_5\")\r\n\r\n### 1.CHAR与 VARCHAR\r\n![20180324_2](/uploads/article/20180324/5ab619ec8d657.png \"20180324_2\")\r\n\r\n**最后一行的值只适用非“严格模式”时，如果MySQL 运行在严格模式，\r\n超过列长度的值将不会保存，并且会出现错误提示**\r\n\r\n从 CHAR(4)和 VARCHAR(4)列检索的值并不总是相同，因为**检索时从 CHAR 列删除了尾部\r\n的空格**。下面通过一个例子说明该差别\r\n\r\n![20180324_4](/uploads/article/20180324/5ab61ad83241b.png \"20180324_4\")\r\n\r\n#### 对比：\r\nCHAR 是固定长度的，所以它的处理速度比 VARCHAR 快得多，但是其缺点是浪费\r\n存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较 高要求的数据可以考虑使用 CHAR 类型来存储。\r\n\r\n#### 选择\r\n在MySQL 中，不同的存储引擎对 CHAR 和 VARCHAR 的使用原则有所不同，这里简单概\r\n括如下。\r\n1. MyISAM存储引擎：建议使用固定长度的数据列代替可变长度的数据列。 \r\n2. MEMORY 存储引擎：目前都使用固定长度的数据行存储，因此无论使用 CHAR 或VARCHAR 列都没有关系。两者都是作为 CHAR 类型处理。 \r\n3. InnoDB 存储引擎：建议使用 VARCHAR 类型。对于 InnoDB 数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在 本质上，使用固定长度的 CHAR 列不一定比使用可变长度 VARCHAR 列性能要好。因而，主 要的性能因素是数据行使用的存储总量。由于 CHAR 平均占用的空间多于VARCHAR，因此使 用 VARCHAR 来最小化需要处理的数据行的存储总量和磁盘 I/O 是比较好的。\r\n\r\n###2.日期类型选择 \r\nMySQL 提供的常用日期类型有 DATE、TIME 、DATETIME、TIMESTAMP。\r\n1.  根据实际需要选择能够满足应用的最小存储的日期类型。如果应用只需要记录“年份”，那么用 1 个字节来存储的 YEAR 类型完全可以满足，而不需要用 4 个字节来存储的 DATE 类型。这样不仅仅能节约存储，更能够提高表的操作效率。\r\n2.  如果要记录年月日时分秒，并且记录的年份比较久远，那么最好使用 DATETIME， 而不要使用 TIMESTAMP。因为 TIMESTAMP 表示的日期范围比DATETIME要短得多。\r\n3.  如果记录的日期需要让不同时区的用户使用，那么最好使用 TIMESTAMP，因为日期类型中只有它能够和实际时区相对应。\r\n\r\n###3.索引概述\r\n每种存储引擎（如MyISAM、 InnoDB、BDB、MEMORY 等）对每个表**至少支持 16 个索引**，总索引长度**至少为 256 字节**。\r\n**MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引。MySQL 目前还不支持函数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引。**前缀索引的长度跟存储引擎相关，对于MyISAM 存储引擎的表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 存储引擎的表，索引的前缀长度最长是 767 字节。请注意前缀的限制应以字节为单 位进行测量，而 CREATE TABLE 语句中的前缀长度解释为字符数。在为使用多字节字符集的 列指定前缀长度时一定要加以考虑','<h3>几种引擎对比</h3><p><img src=\"/uploads/article/20180324/5ab65dd5b8645.png\" alt=\"20180324_5\" title=\"20180324_5\"></p><h3>1.CHAR与 VARCHAR</h3><p><img src=\"/uploads/article/20180324/5ab619ec8d657.png\" alt=\"20180324_2\" title=\"20180324_2\"></p><p>**最后一行的值只适用非“严格模式”时，如果MySQL 运行在严格模式，<br>超过列长度的值将不会保存，并且会出现错误提示**</p><p>从 CHAR(4)和 VARCHAR(4)列检索的值并不总是相同，因为**检索时从 CHAR 列删除了尾部<br>的空格**。下面通过一个例子说明该差别</p><p><img src=\"/uploads/article/20180324/5ab61ad83241b.png\" alt=\"20180324_4\" title=\"20180324_4\"></p><h4>对比：</h4><p>CHAR 是固定长度的，所以它的处理速度比 VARCHAR 快得多，但是其缺点是浪费<br>存储空间，程序需要对行尾空格进行处理，所以对于那些长度变化不大并且对查询速度有较 高要求的数据可以考虑使用 CHAR 类型来存储。</p><h4>选择</h4><p>在MySQL 中，不同的存储引擎对 CHAR 和 VARCHAR 的使用原则有所不同，这里简单概<br>括如下。</p><ol><li>MyISAM存储引擎：建议使用固定长度的数据列代替可变长度的数据列。</li><li>MEMORY 存储引擎：目前都使用固定长度的数据行存储，因此无论使用 CHAR 或VARCHAR 列都没有关系。两者都是作为 CHAR 类型处理。</li><li>InnoDB 存储引擎：建议使用 VARCHAR 类型。对于 InnoDB 数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在 本质上，使用固定长度的 CHAR 列不一定比使用可变长度 VARCHAR 列性能要好。因而，主 要的性能因素是数据行使用的存储总量。由于 CHAR 平均占用的空间多于VARCHAR，因此使 用 VARCHAR 来最小化需要处理的数据行的存储总量和磁盘 I/O 是比较好的。</li></ol><h3>2.日期类型选择</h3><p>MySQL 提供的常用日期类型有 DATE、TIME 、DATETIME、TIMESTAMP。</p><ol><li>根据实际需要选择能够满足应用的最小存储的日期类型。如果应用只需要记录“年份”，那么用 1 个字节来存储的 YEAR 类型完全可以满足，而不需要用 4 个字节来存储的 DATE 类型。这样不仅仅能节约存储，更能够提高表的操作效率。</li><li>如果要记录年月日时分秒，并且记录的年份比较久远，那么最好使用 DATETIME， 而不要使用 TIMESTAMP。因为 TIMESTAMP 表示的日期范围比DATETIME要短得多。</li><li>如果记录的日期需要让不同时区的用户使用，那么最好使用 TIMESTAMP，因为日期类型中只有它能够和实际时区相对应。</li></ol><h3>3.索引概述</h3><p>每种存储引擎（如MyISAM、 InnoDB、BDB、MEMORY 等）对每个表<strong>至少支持 16 个索引</strong>，总索引长度<strong>至少为 256 字节</strong>。<br><strong>MyISAM 和 InnoDB 存储引擎的表默认创建的都是 BTREE 索引。MySQL 目前还不支持函数索引，但是支持前缀索引，即对索引字段的前 N 个字符创建索引。</strong>前缀索引的长度跟存储引擎相关，对于MyISAM 存储引擎的表，索引的前缀长度可以达到 1000 字节长，而对于 InnoDB 存储引擎的表，索引的前缀长度最长是 767 字节。请注意前缀的限制应以字节为单 位进行测量，而 CREATE TABLE 语句中的前缀长度解释为字符数。在为使用多字节字符集的 列指定前缀长度时一定要加以考虑</p>','1.CHAR与 VARCHAR最后一行的值只适用非“严格模式”时，如果MySQL 运行在严格模式，超过列长度的值将不会保存，并且会出现错误提示从 CHAR(4)和 VARCHAR(4)列检索的值并不总是相同，因为检索时从 CHAR 列删除了尾部的空格。下面通过一个例子说明该差别 对比：CHAR 是固定长度的，所以它的处理速度比 VARCHAR 快得多，但是...','mysql,小知识','/uploads/article/20180324/5ab65dd5b8645.png',0,2,'2018-03-24 17:33:00','2018-03-25 17:36:39',NULL),(32,1,'PHP OOP 面向对象简说','汤一碗','## PHP的面向对象简说\r\n### 面向对象中的最重要的2个概念\r\n#### 类：（类是一种思想上的或者未实现的东西）\r\n所有描述事物的概念就是类,所有事物的操作流程也是一个类\r\n\r\n#### 对象:\r\n所有事物的操作流程的实施过程就是一个对象\r\n\r\n#### 类和对象的组成成分:\r\n一种是用于对特征的描述 成员属性\r\n\r\n一种是对其功能的描述 成员方法\r\n\r\n### 类的书写规则\r\n#### 1.文件名\r\na) 函数的文件名 xxx.func.php\r\n\r\nb) 类的文件名 xxx.class.php（单类文件）\r\n\r\n类的文件名一般与类名相同\r\n\r\n类的驼峰命名法:每个单词的首字母大写\r\n\r\n####2.类的书写规则\r\n类必须有class关键字开始\r\n\r\nClass关键字之后跟类名，类名通常和文件名相同\r\n\r\n类名之后直接跟{}即可\r\n\r\n####3.成员属性的书写规则\r\n声明成员属性必须使用关键字 var或者public private等.\r\n\r\n声明成员属性可以赋值，可以不赋值\r\n\r\n声明成员属性是，不能赋一个函数\r\n\r\n成员属性的最大作用为成员方法提供一个桥梁的作用\r\n\r\n####4.成员方法的书写规则(同函数)\r\n声明成员方法是需要使用function关键字\r\n\r\n声明成员方法可以传入参数，也可以不传入参数\r\n\r\n声明成员方法，方法允许存在返回值\r\n\r\n类中只能出现成员属性和成员方法，不允许出现其他代码否则会有语法错误\r\n对象的生成和使用方法\r\n一般情况下，类是无法直接使用的，需要将类实例化成对象之后才可以使用。\r\n\r\n####实例化对象的方法：\r\n变量= new 类名；\r\n或者\r\n变量 = new 类名();\r\n\r\n####使用对象的成员属性\r\n对象变量->成员属性名\r\n\r\n####使用对象的成员方法\r\n对象变量->成员方法名()\r\n$this 关键字\r\n在当前对象中的成员方法中调用当前对象中的成员属性\r\n$this->表示当前对象\r\n如果代码中具有$this->那么该类必须实例化才能使用\r\n使用方法\r\n$this->属性名\r\n\r\n###魔术方法: 一种特殊的函数\r\n\r\n####1.构造方法:__construct（）或者类名相同\r\n触发时机：在对象实例化的时候自动触发\r\n作用: 初始化成员属性\r\n参数: 可以有，可以没有 取决于设定和逻辑\r\n返回值；没有\r\n注意:如果构造方法具有参数，且参数没有默认值，在实例化是必须在类名()内添加对应的实参值;\r\n\r\n####2.析构方法:__destruct()\r\n触发时机：在销毁对象的时候自动触发（unset或者页面执行完毕）\r\n作用: 回收对象使用过程中的资源\r\n参数: 没有\r\n返回值；没有\r\n\r\n###面向对象的三大特征：\r\n####封装，继承 和多态\r\n封装特性:在一个对象产生之后，对象的部分成员属性和成员方法逻辑上是不允许在对象外部进行调用或者使用的，这就是封装的特性\r\n\r\n封装关键字 private 私有的\r\n\r\n####Private的特征:\r\n1.被private修饰的成员属性不能够在类的外部访问，可以在类的内部访问\r\n2.被private修饰的成员方法也不能在类的外部访问\r\n3.Var 和private只能选取一个（还包括public 和protected）\r\n\r\n####魔术方法3:__get()\r\n触发时机:访问私有成员属性的时候自动触发\r\n作用:1.防止报错 2.为私有的成员属性访问提供后门\r\n参数: 1个 访问私有的成员属性名称\r\n返回值:可以有也可以没有\r\n\r\n####魔术方法4：__set()\r\n触发时机: 对私有成员属性进行设置值的时候自动触发\r\n作用:1.屏蔽错误 2.为私有成员属性设置值\r\n参数:2个 1.私有成员属性名 2.要设置的值\r\n返回值:无\r\n\r\n####魔术方法5：__isset()\r\n触发时机: 对私有的成员属性进行isset检测时自动触发\r\n作用:代替外部的isset检测 返回结果\r\n参数:1个 1.私有成员属性名\r\n返回值:有 一般返回isset(属性)结果\r\n\r\n####魔术方法6：__unset()\r\n触发时机:对私有的成员属性进行unset操作时自动触发\r\n作用: 代替外部的unset删除\r\n参数：1个 1.私有的成员属性名\r\n返回值：无\r\n\r\n####封装的三个关键字：\r\nPrivate : 私有化封装\r\n\r\nProtected: 受保护封装\r\n\r\nPublic 公共的封装\r\n\r\n```php\r\n关键字/位置	     类外 	        子类	    类内\r\nPrivate(私有)	     ×	         ×	     √\r\nProtected(保密)     ×	         √	     √\r\nPublic(共有) 	     √	         √	     √\r\n```\r\n\r\n\r\n\r\n继承特性：\r\n\r\n继承的格式：\r\n\r\n```c\r\nClass 类名 extends 父类名{\r\n//子类独有的属性和方法\r\n}\r\n```\r\n\r\n\r\n\r\n#### 概念\r\n父类:被其他类继承的类就是父类 也叫做基类\r\n\r\n子类：继承其他类的类就是子类也叫派生类\r\n\r\n父类私有的属性 和方法 子类是不能继承\r\n\r\nPhp继承特点和其他语言的不同：\r\n\r\nPhp 语言是单继承\r\n其他语言是多继承\r\n\r\n####继承的特点：\r\n1.子类继承父类具有父类的所有成员属性和成员方法(私有的除外)\r\n\r\n2.子类继承父类之后可以具有子类独有的属性和方法\r\n\r\n3.在继承时，子类中允许出现和父类同名的方法，这种情况不冲突，而是子类的方法会覆盖父类的方法，这种方法叫做重载\r\n\r\n4.魔术方法也可以被子类继承\r\n\r\n5.如果父类具有构造方法，子类也具有需要构造方法进行构造的成员属性，此时需要在子类中重载父类的构造方法，并且在构造方法中使用parent::__construct() （也可以使用类名代替parent不推荐）进行调用父类的构造方法，构造继承而来的父类的成员属性\r\n\r\n6.继承代码的时候不要瞎继承，人类不要继承猫类 不会变成猫人````\r\n\r\n#### 属性的重载\r\nPublic修饰的属性如果在子类有同名的属性会被重写\r\n不管写在父类还是子类的方法访问这个属性都是被重载之后的值\r\n\r\nProtected 父类中 如果是protected修饰属性 或方法 子类只能是protected或者public\r\nPrivate 父类修饰的属性 那么太就有讲究了\r\n\r\n#### 权限关系\r\nPrivate 1\r\n\r\nProtected 2\r\n\r\nPublic 3\r\n\r\n权限可以扩大不能缩小\r\n\r\n#### Final 关键字\r\nFinal 意思 最后的 最终的\r\n\r\n作用\r\n1.修饰成员方法 禁止子类在重载父类的方法\r\n2.用来修饰类 被final 修饰的类无法被继承\r\n\r\n#### Const 关键字\r\n作用:用于在类中声明常量，这个常量是类中的常量\r\n\r\n类中的常量不归对象所有，而是归类所有(你有类声明常量是类的不是对象的)\r\n\r\n在类中声明常量const\r\n\r\n声明常量时需要给常量赋值\r\n\r\n声明常量归类所有不是归任何对象所有\r\n\r\n#### 类中常量的访问方式\r\n\r\na) 类外部\r\n类名::常量名\r\n\r\nb) 类内部\r\n类名：：常量名\r\n\r\nSelf::常量名\r\n\r\nSelf表示当前类 $this->表示当前对象\r\n\r\n#### Static 关键字\r\n在类中使用static 声明的成员属性都是静态成员属性 声明的成员方法都是静态的成员方法\r\n静态的成员特征是：不归对象所有，而是归类所有\r\n\r\n1.static关键字及可以修饰成员属性也可以修饰成员方法\r\n\r\n2.Static 声明的成员都是归类所有，而不是归对象所有在没有对象的情况下，可以通过类来访问\r\n\r\n3.能声明静态的成员就需要声明静态的成员 效率高~~~\r\n\r\n4.具有动态的成员方法不可以声明为静态的成员方法（没有$this）\r\n\r\n5.如果方法中没有$this存在，那么这个方法实际上已经是静态的方法(版本>5.3请你写上static关键字)\r\n\r\n#### 静态的成员访问\r\n类内部\r\n\r\n类名::$静态的成员属性名\r\n\r\nSelf::$静态的成员属性名\r\n\r\n类名::静态的成员方法名();\r\n\r\nSelf::静态的成员方法名();\r\n\r\n类外部\r\n\r\n类名::$静态的成员属性名;\r\n\r\n类名::静态成员方法名();\r\n\r\n对象->静态的成员方法名();（一般不用）\r\n\r\n#### 对象的串行化\r\n将对象编程一个字符串的过程就是兑现高度串行化\r\n\r\n作用:1.方便长久的保存对象，2方便在网络上传输\r\n\r\n串行化操作:变量 = serialize(对象变量)\r\n\r\n反串行化操作：\r\n对象变量 = unserialize(变量)\r\n\r\n#### 魔术方法7：__sleep()\r\n\r\n触发时机:在对象进行串行化操作的时候自动触发\r\n\r\n功能; 执行需要串行化的成员属性\r\n\r\n参数: 无\r\n\r\n返回值:需要返回一个数组类型，每个元素都是要串行化的成员属性名\r\n\r\n#### 魔术方法 8:__wakeup()\r\n触发时机:在对象进行反串行化操作的时候自动触发\r\n功能;反串行化的时候自动修改部分成员属性值\r\n参数: 无\r\n返回值:无\r\n\r\n#### 魔术方法 9:__toString()\r\n触发时机:在一个对象进行echo 操作的时候自动触发\r\n功能;简化操作或者为对象输出值\r\n参数: 无\r\n返回值:必须有且必须为字符串类型\r\n\r\n#### 魔术方法10:__clone()\r\n触发时机:对对象进行克隆操作的时候自动触发\r\n功能;修改克隆之后的对象的部分属性值\r\n参数: 无\r\n返回值:无\r\n\r\n注意：对象的赋值默认就是引用赋值，不能通过赋值操作获取一个新的对象，获取新的对象的操作应该使用克隆操作\r\n格式:变量=clone 对象变量\r\n\r\n#### 魔术方法11__call()\r\n触发时机:调用了类中不存在的方法时自动触发\r\n功能;1.屏蔽错误2.为不存在的方法定义一个功能\r\n参数: 2个 1.不存在的方法名 2.所有实参组成的数组\r\n返回值:可有可无(根据实际功能决定)\r\n\r\n#### 魔术方法 12__autoload();\r\n触发时机:当页面需要加载一个类而该类不存在时自动触发\r\n功能;实现类的自动加载\r\n参数: 1个 1.不存在类的类名\r\n返回值:没有\r\n\r\n##抽象类\r\n具有抽象方法的类就是抽象类\r\n\r\n####抽象方法：\r\n\r\n没有方法体的方法就是抽象方法\r\n\r\n作用：领导用的~~协同工作 制定标准\r\n\r\n####特征:\r\n1.抽象方法就是没有方法体的方法，方法体相当于函数体，抽象方法前面必须使用abstract关键字 且方法后不能写{} 但是要写;\r\n\r\n2.如果类中有抽象方法，那么这个类前面必须使用abstract关键字修饰\r\n\r\n3.抽象类中可以具有非抽象方法\r\n\r\n4.抽象方法可以具有参数，要实现抽象方法必须传入同样的参数\r\n\r\n5.抽象类不能直接使用 必须由其他类继承 并且全部实现所有的抽象方法才可以使用，抽象类的主要是给其他类进行继承操作的\r\n\r\n6.抽象类可以继承抽象类\r\n\r\n7.在抽象类中抽象方法不可以使用private关键字\r\n\r\n#### 接口:\r\n如果一个类中没有任何的**非抽象方法**，且不存在除常量以外的任何成员属性，那么这个类就是一个接口\r\n\r\n特征：\r\n\r\n1.声明一个接口不使用class关键字 而是用interface 关键字\r\n\r\n2.接口中的抽象方法不需要写abstract关键字 虽然他是抽象类\r\n\r\n3.接口可以使用public 关键字 不可以使用protected或者private关键字\r\n\r\n4.接口不允许有任何的成员属性，除了常量。\r\n\r\n5.接口的继承不使用extends 而使用implements 关键字\r\n\r\n6.extends 只能继承一个普通类或者一个抽象类，而implements可以同时继承多个接口，从而模拟多继承\r\n\r\n####面向对象三大特性 封装 继承 多态','<h2>PHP的面向对象简说</h2><h3>面向对象中的最重要的2个概念</h3><h4>类：（类是一种思想上的或者未实现的东西）</h4><p>所有描述事物的概念就是类,所有事物的操作流程也是一个类</p><h4>对象:</h4><p>所有事物的操作流程的实施过程就是一个对象</p><h4>类和对象的组成成分:</h4><p>一种是用于对特征的描述 成员属性</p><p>一种是对其功能的描述 成员方法</p><h3>类的书写规则</h3><h4>1.文件名</h4><p>a) 函数的文件名 xxx.func.php</p><p>b) 类的文件名 xxx.class.php（单类文件）</p><p>类的文件名一般与类名相同</p><p>类的驼峰命名法:每个单词的首字母大写</p><h4>2.类的书写规则</h4><p>类必须有class关键字开始</p><p>Class关键字之后跟类名，类名通常和文件名相同</p><p>类名之后直接跟{}即可</p><h4>3.成员属性的书写规则</h4><p>声明成员属性必须使用关键字 var或者public private等.</p><p>声明成员属性可以赋值，可以不赋值</p><p>声明成员属性是，不能赋一个函数</p><p>成员属性的最大作用为成员方法提供一个桥梁的作用</p><h4>4.成员方法的书写规则(同函数)</h4><p>声明成员方法是需要使用function关键字</p><p>声明成员方法可以传入参数，也可以不传入参数</p><p>声明成员方法，方法允许存在返回值</p><p>类中只能出现成员属性和成员方法，不允许出现其他代码否则会有语法错误<br>对象的生成和使用方法<br>一般情况下，类是无法直接使用的，需要将类实例化成对象之后才可以使用。</p><h4>实例化对象的方法：</h4><p>变量= new 类名；<br>或者<br>变量 = new 类名();</p><h4>使用对象的成员属性</h4><p>对象变量-&gt;成员属性名</p><h4>使用对象的成员方法</h4><p>对象变量-&gt;成员方法名()<br>$this 关键字<br>在当前对象中的成员方法中调用当前对象中的成员属性<br>$this-&gt;表示当前对象<br>如果代码中具有$this-&gt;那么该类必须实例化才能使用<br>使用方法<br>$this-&gt;属性名</p><h3>魔术方法: 一种特殊的函数</h3><h4>1.构造方法:__construct（）或者类名相同</h4><p>触发时机：在对象实例化的时候自动触发<br>作用: 初始化成员属性<br>参数: 可以有，可以没有 取决于设定和逻辑<br>返回值；没有<br>注意:如果构造方法具有参数，且参数没有默认值，在实例化是必须在类名()内添加对应的实参值;</p><h4>2.析构方法:__destruct()</h4><p>触发时机：在销毁对象的时候自动触发（unset或者页面执行完毕）<br>作用: 回收对象使用过程中的资源<br>参数: 没有<br>返回值；没有</p><h3>面向对象的三大特征：</h3><h4>封装，继承 和多态</h4><p>封装特性:在一个对象产生之后，对象的部分成员属性和成员方法逻辑上是不允许在对象外部进行调用或者使用的，这就是封装的特性</p><p>封装关键字 private 私有的</p><h4>Private的特征:</h4><p>1.被private修饰的成员属性不能够在类的外部访问，可以在类的内部访问<br>2.被private修饰的成员方法也不能在类的外部访问<br>3.Var 和private只能选取一个（还包括public 和protected）</p><h4>魔术方法3:__get()</h4><p>触发时机:访问私有成员属性的时候自动触发<br>作用:1.防止报错 2.为私有的成员属性访问提供后门<br>参数: 1个 访问私有的成员属性名称<br>返回值:可以有也可以没有</p><h4>魔术方法4：__set()</h4><p>触发时机: 对私有成员属性进行设置值的时候自动触发<br>作用:1.屏蔽错误 2.为私有成员属性设置值<br>参数:2个 1.私有成员属性名 2.要设置的值<br>返回值:无</p><h4>魔术方法5：__isset()</h4><p>触发时机: 对私有的成员属性进行isset检测时自动触发<br>作用:代替外部的isset检测 返回结果<br>参数:1个 1.私有成员属性名<br>返回值:有 一般返回isset(属性)结果</p><h4>魔术方法6：__unset()</h4><p>触发时机:对私有的成员属性进行unset操作时自动触发<br>作用: 代替外部的unset删除<br>参数：1个 1.私有的成员属性名<br>返回值：无</p><h4>封装的三个关键字：</h4><p>Private : 私有化封装</p><p>Protected: 受保护封装</p><p>Public 公共的封装</p><pre><code class=\"lang-php\">关键字/位置         类外             子类        类内\nPrivate(私有)         ×             ×         √\nProtected(保密)     ×             √         √\nPublic(共有)          √             √         √</code></pre><p>继承特性：</p><p>继承的格式：</p><pre><code class=\"lang-c\">Class 类名 extends 父类名{\n//子类独有的属性和方法\n}</code></pre><h4>概念</h4><p>父类:被其他类继承的类就是父类 也叫做基类</p><p>子类：继承其他类的类就是子类也叫派生类</p><p>父类私有的属性 和方法 子类是不能继承</p><p>Php继承特点和其他语言的不同：</p><p>Php 语言是单继承<br>其他语言是多继承</p><h4>继承的特点：</h4><p>1.子类继承父类具有父类的所有成员属性和成员方法(私有的除外)</p><p>2.子类继承父类之后可以具有子类独有的属性和方法</p><p>3.在继承时，子类中允许出现和父类同名的方法，这种情况不冲突，而是子类的方法会覆盖父类的方法，这种方法叫做重载</p><p>4.魔术方法也可以被子类继承</p><p>5.如果父类具有构造方法，子类也具有需要构造方法进行构造的成员属性，此时需要在子类中重载父类的构造方法，并且在构造方法中使用parent::__construct() （也可以使用类名代替parent不推荐）进行调用父类的构造方法，构造继承而来的父类的成员属性</p><p>6.继承代码的时候不要瞎继承，人类不要继承猫类 不会变成猫人<code>`</code>`</p><h4>属性的重载</h4><p>Public修饰的属性如果在子类有同名的属性会被重写<br>不管写在父类还是子类的方法访问这个属性都是被重载之后的值</p><p>Protected 父类中 如果是protected修饰属性 或方法 子类只能是protected或者public<br>Private 父类修饰的属性 那么太就有讲究了</p><h4>权限关系</h4><p>Private 1</p><p>Protected 2</p><p>Public 3</p><p>权限可以扩大不能缩小</p><h4>Final 关键字</h4><p>Final 意思 最后的 最终的</p><p>作用<br>1.修饰成员方法 禁止子类在重载父类的方法<br>2.用来修饰类 被final 修饰的类无法被继承</p><h4>Const 关键字</h4><p>作用:用于在类中声明常量，这个常量是类中的常量</p><p>类中的常量不归对象所有，而是归类所有(你有类声明常量是类的不是对象的)</p><p>在类中声明常量const</p><p>声明常量时需要给常量赋值</p><p>声明常量归类所有不是归任何对象所有</p><h4>类中常量的访问方式</h4><p>a) 类外部<br>类名::常量名</p><p>b) 类内部<br>类名：：常量名</p><p>Self::常量名</p><p>Self表示当前类 $this-&gt;表示当前对象</p><h4>Static 关键字</h4><p>在类中使用static 声明的成员属性都是静态成员属性 声明的成员方法都是静态的成员方法<br>静态的成员特征是：不归对象所有，而是归类所有</p><p>1.static关键字及可以修饰成员属性也可以修饰成员方法</p><p>2.Static 声明的成员都是归类所有，而不是归对象所有在没有对象的情况下，可以通过类来访问</p><p>3.能声明静态的成员就需要声明静态的成员 效率高~~~</p><p>4.具有动态的成员方法不可以声明为静态的成员方法（没有$this）</p><p>5.如果方法中没有$this存在，那么这个方法实际上已经是静态的方法(版本&gt;5.3请你写上static关键字)</p><h4>静态的成员访问</h4><p>类内部</p><p>类名::$静态的成员属性名</p><p>Self::$静态的成员属性名</p><p>类名::静态的成员方法名();</p><p>Self::静态的成员方法名();</p><p>类外部</p><p>类名::$静态的成员属性名;</p><p>类名::静态成员方法名();</p><p>对象-&gt;静态的成员方法名();（一般不用）</p><h4>对象的串行化</h4><p>将对象编程一个字符串的过程就是兑现高度串行化</p><p>作用:1.方便长久的保存对象，2方便在网络上传输</p><p>串行化操作:变量 = serialize(对象变量)</p><p>反串行化操作：<br>对象变量 = unserialize(变量)</p><h4>魔术方法7：__sleep()</h4><p>触发时机:在对象进行串行化操作的时候自动触发</p><p>功能; 执行需要串行化的成员属性</p><p>参数: 无</p><p>返回值:需要返回一个数组类型，每个元素都是要串行化的成员属性名</p><h4>魔术方法 8:__wakeup()</h4><p>触发时机:在对象进行反串行化操作的时候自动触发<br>功能;反串行化的时候自动修改部分成员属性值<br>参数: 无<br>返回值:无</p><h4>魔术方法 9:__toString()</h4><p>触发时机:在一个对象进行echo 操作的时候自动触发<br>功能;简化操作或者为对象输出值<br>参数: 无<br>返回值:必须有且必须为字符串类型</p><h4>魔术方法10:__clone()</h4><p>触发时机:对对象进行克隆操作的时候自动触发<br>功能;修改克隆之后的对象的部分属性值<br>参数: 无<br>返回值:无</p><p>注意：对象的赋值默认就是引用赋值，不能通过赋值操作获取一个新的对象，获取新的对象的操作应该使用克隆操作<br>格式:变量=clone 对象变量</p><h4>魔术方法11__call()</h4><p>触发时机:调用了类中不存在的方法时自动触发<br>功能;1.屏蔽错误2.为不存在的方法定义一个功能<br>参数: 2个 1.不存在的方法名 2.所有实参组成的数组<br>返回值:可有可无(根据实际功能决定)</p><h4>魔术方法 12__autoload();</h4><p>触发时机:当页面需要加载一个类而该类不存在时自动触发<br>功能;实现类的自动加载<br>参数: 1个 1.不存在类的类名<br>返回值:没有</p><h2>抽象类</h2><p>具有抽象方法的类就是抽象类</p><h4>抽象方法：</h4><p>没有方法体的方法就是抽象方法</p><p>作用：领导用的~~协同工作 制定标准</p><h4>特征:</h4><p>1.抽象方法就是没有方法体的方法，方法体相当于函数体，抽象方法前面必须使用abstract关键字 且方法后不能写{} 但是要写;</p><p>2.如果类中有抽象方法，那么这个类前面必须使用abstract关键字修饰</p><p>3.抽象类中可以具有非抽象方法</p><p>4.抽象方法可以具有参数，要实现抽象方法必须传入同样的参数</p><p>5.抽象类不能直接使用 必须由其他类继承 并且全部实现所有的抽象方法才可以使用，抽象类的主要是给其他类进行继承操作的</p><p>6.抽象类可以继承抽象类</p><p>7.在抽象类中抽象方法不可以使用private关键字</p><h4>接口:</h4><p>如果一个类中没有任何的<strong>非抽象方法</strong>，且不存在除常量以外的任何成员属性，那么这个类就是一个接口</p><p>特征：</p><p>1.声明一个接口不使用class关键字 而是用interface 关键字</p><p>2.接口中的抽象方法不需要写abstract关键字 虽然他是抽象类</p><p>3.接口可以使用public 关键字 不可以使用protected或者private关键字</p><p>4.接口不允许有任何的成员属性，除了常量。</p><p>5.接口的继承不使用extends 而使用implements 关键字</p><p>6.extends 只能继承一个普通类或者一个抽象类，而implements可以同时继承多个接口，从而模拟多继承</p><h4>面向对象三大特性 封装 继承 多态</h4>',' PHP的面向对象简说\r\n 面向对象中的最重要的2个概念\r\n 类：（类是一种思想上的或者未实现的东西）\r\n所有描述事物的概念就是类,所有事物的操作流程也是一个类\r\n\r\n 对象:\r\n所有事物的操作流程的实施过程就是一个对象\r\n\r\n 类和对象的组成成分:\r\n一种是用于对特征的描述 成员属性\r\n\r\n一种是对其功能的描述 成员方法\r\n\r\n 类的书写规则\r\n 1.文件名\r\na) 函数的文件名 xxx.fun...','OOP,面向对象','uploads/article/default.jpg',0,1,'2018-03-25 11:41:22','2018-03-25 11:50:10',NULL),(33,5,'Mysql锁的使用及事务控制基本命令总结','汤一碗','###lock table A  read/write\r\n获得表 A 的 READ/WRITE 锁定\r\n###unlock tables\r\n释放所有表锁\r\n![21080325_1](/uploads/article/20180325/5ab7406227341.png \"21080325_1\")\r\n\r\n###事务控制\r\nMySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支持本地事务，具体语法如下。\r\n**START TRANSACTION | BEGIN [WORK] \r\nCOMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \r\nROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] \r\nSET AUTOCOMMIT = {0 | 1}**\r\n\r\n默认情况下，MySQL 是自动提交（Autocommit）的，（自动执行start transaction和commit命令）\r\n1. START TRANSACTION或 BEGIN语句可以开始一项新的事务。 \r\n2. COMMIT 和ROLLBACK 用来提交或者回滚事务。 \r\n3. CHAIN 和 RELEASE 子句分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立即启动一个新事物，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的 连接。\r\n4. SET AUTOCOMMIT 可以修改当前连接的提交方式，如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。\r\n\r\n\r\n![20180325_2](/uploads/article/20180325/5ab741c6dbd03.png \"20180325_2\")\r\n![20180325_3](/uploads/article/20180325/5ab742160c1d9.png \"20180325_3\")\r\n![20180325_4](/uploads/article/20180325/5ab7422e47a2d.png \"20180325_4\")\r\n![20180325_5](/uploads/article/20180325/5ab7423cc1cae.png \"20180325_5\")\r\n\r\n**如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock tables 被执行**\r\n\r\n![20180325_6](/uploads/article/20180325/5ab7427777f7d.png \"20180325_6\")\r\n![20180325_7](/uploads/article/20180325/5ab74286b2dc7.png \"20180325_7\")\r\n\r\n**注意，上表中的rollback命令无作用，因为对lock 方式加的表锁，不能通过rollback进行回滚。**\r\n\r\n###回滚的灵活用法：SAVEPOINT\r\n在事务中可以通过定义 SAVEPOINT，指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 SAVEPOINT，满足不同的条件时，回滚不同的 SAVEPOINT。需要注意的是，如果定义了相同名字的 SAVEPOINT，则后面定义的 SAVEPOINT 会覆盖之前的定义。对于不再需要使用的 SAVEPOINT，可以通过 RELEASE SAVEPOINT 命令删除 SAVEPOINT，删除后的 SAVEPOINT，不能再执行 ROLLBACK TO SAVEPOINT 命令。\r\n![20180325_8](/uploads/article/20180325/5ab7478ea5c36.png \"20180325_8\")\r\n![20180325_9](/uploads/article/20180325/5ab7479d43ca6.png \"20180325_9\")![20180325_9](/uploads/article/20180325/5ab747bc4e146.png \"20180325_9\")','<h3>lock table A  read/write</h3><p>获得表 A 的 READ/WRITE 锁定</p><h3>unlock tables</h3><p>释放所有表锁<br><img src=\"/uploads/article/20180325/5ab7406227341.png\" alt=\"21080325_1\" title=\"21080325_1\"></p><h3>事务控制</h3><p>MySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支持本地事务，具体语法如下。<br>**START TRANSACTION | BEGIN [WORK] <br>COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE] <br>ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE] <br>SET AUTOCOMMIT = {0 | 1}**</p><p>默认情况下，MySQL 是自动提交（Autocommit）的，（自动执行start transaction和commit命令）</p><ol><li>START TRANSACTION或 BEGIN语句可以开始一项新的事务。</li><li>COMMIT 和ROLLBACK 用来提交或者回滚事务。</li><li>CHAIN 和 RELEASE 子句分别用来定义在事务提交或者回滚之后的操作，CHAIN 会立即启动一个新事物，并且和刚才的事务具有相同的隔离级别，RELEASE 则会断开和客户端的 连接。</li><li>SET AUTOCOMMIT 可以修改当前连接的提交方式，如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚。</li></ol><p><img src=\"/uploads/article/20180325/5ab741c6dbd03.png\" alt=\"20180325_2\" title=\"20180325_2\"><br><img src=\"/uploads/article/20180325/5ab742160c1d9.png\" alt=\"20180325_3\" title=\"20180325_3\"><br><img src=\"/uploads/article/20180325/5ab7422e47a2d.png\" alt=\"20180325_4\" title=\"20180325_4\"><br><img src=\"/uploads/article/20180325/5ab7423cc1cae.png\" alt=\"20180325_5\" title=\"20180325_5\"></p><p><strong>如果在锁表期间，用 start transaction 命令开始一个新事务，会造成一个隐含的 unlock tables 被执行</strong></p><p><img src=\"/uploads/article/20180325/5ab7427777f7d.png\" alt=\"20180325_6\" title=\"20180325_6\"><br><img src=\"/uploads/article/20180325/5ab74286b2dc7.png\" alt=\"20180325_7\" title=\"20180325_7\"></p><p><strong>注意，上表中的rollback命令无作用，因为对lock 方式加的表锁，不能通过rollback进行回滚。</strong></p><h3>回滚的灵活用法：SAVEPOINT</h3><p>在事务中可以通过定义 SAVEPOINT，指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 SAVEPOINT，满足不同的条件时，回滚不同的 SAVEPOINT。需要注意的是，如果定义了相同名字的 SAVEPOINT，则后面定义的 SAVEPOINT 会覆盖之前的定义。对于不再需要使用的 SAVEPOINT，可以通过 RELEASE SAVEPOINT 命令删除 SAVEPOINT，删除后的 SAVEPOINT，不能再执行 ROLLBACK TO SAVEPOINT 命令。<br><img src=\"/uploads/article/20180325/5ab7478ea5c36.png\" alt=\"20180325_8\" title=\"20180325_8\"><br><img src=\"/uploads/article/20180325/5ab7479d43ca6.png\" alt=\"20180325_9\" title=\"20180325_9\"><img src=\"/uploads/article/20180325/5ab747bc4e146.png\" alt=\"20180325_9\" title=\"20180325_9\"></p>','lock table A  read/write获得表 A 的 READ/WRITE 锁定unlock tables释放所有表锁事务控制MySQL 通过 SET AUTOCOMMIT、START TRANSACTION、COMMIT 和 ROLLBACK 等语句支持本地事务，具体语法如下。START TRANSACTION | BEGIN  COMMIT  ...','事务,mysql','/uploads/article/20180325/5ab7406227341.png',0,1,'2018-03-25 14:31:34','2018-03-25 17:35:58',NULL),(34,3,'Git使用心得','汤一碗','一些难点（对我来说）查阅了很多资料，依然懵懵懂懂，先总结一下，之后补充。\r\n## git pull = git fetch + git merge\r\n很好理解，fetch将代码拉取到本地暂存，merge再将本地暂存的代码合并到代码库\r\n## git merge 和 git merge -no-ff\r\n![2018035_12](/uploads/article/20180325/5ab7623c4558d.png \"2018035_12\")\r\ngit merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。\r\n\r\ngit merge 则不会显示 feature，只保留单条分支记录。\r\n## 关于git pull -rebase和git pull\r\n这个问题的本质是变基和合并的选择，merge进行合并并提交之后，之前的所有提交将被丢弃，只保留merge的提交信息。而rebase变基的过程却是将分支的起点移动到了最新版本之后，保留了所有提交信息。如下。\r\n```c\r\nrebase\r\n    A---B---C topic\r\n   /\r\n  D---E---F---G master\r\n  \r\n                A\'--B\'--C\' topic\r\n               /\r\n  D---E---F---G master\r\n ```\r\n ```c\r\n merge\r\n      A---B---C topic\r\n     /\r\n    D---E---F---G master\r\n	\r\n	 A-----B---C topic\r\n     /          \\\r\n     D---E---F---G---H master\r\n ```\r\n merge相当于把两个分支合并成一个新的分支，被合并的分支所有提交会丢失且变成一个merge提交合并到另一个分支（**只需要解决一次冲突**）。\r\nrebase相等于从当前分支创建一个新的分支，再把另一个分支的提交记录一个个提交到新创建的分支。”优势是会保留所有的提交记录，劣势是两个分支差异太大的时候很要命（**需要分别解决多次冲突**）。\r\n####[变基和合并](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA \"变基和合并\")\r\n####[如何选择merge和rebase](https://www.zhihu.com/question/36509119 \"如何选择merge和rebase\")\r\n####[深入理解merge和rebase](https://www.atlassian.com/git/tutorials/merging-vs-rebasing \"深入理解merge和rebase\")\r\n## 关于git pull -rebase和git stash （save） && git stash pop/apply\r\n\r\n#### 先说一下pop和apply\r\ngit stash apply，会将当前分支的最后一次缓存的内容释放出来，但是刚才的**记录还存在list中**\r\n\r\ngit stash pop，也会将当前分支的最后一次缓存的内容释放出来，但是刚才的**记录不存在list中**\r\nps： git stash clear清空stash\r\n#### 再说一下怎么区分rebase和stash使用场景\r\n![20180325_10](/uploads/article/20180325/5ab758ed4c393.png \"20180325_10\")\r\n这两个其实是比较好理解的，当在分支进行开发时，突然需要拉取新版代码，又不想放弃当前开发进度（废话），这时就有两个选择：\r\n1. 将当前修改内容commit，然后使用git pull -rebase命令将本地commit内容连接到远处最新commit后。**rebase 在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。**\r\n2. 不提交当前更改，使用git stash储藏改动的代码，使用git pull拉取后再git stash pop将储藏的改动取出。','<p>一些难点（对我来说）查阅了很多资料，依然懵懵懂懂，先总结一下，之后补充。</p><h2>git pull = git fetch + git merge</h2><p>很好理解，fetch将代码拉取到本地暂存，merge再将本地暂存的代码合并到代码库</p><h2>git merge 和 git merge -no-ff</h2><p><img src=\"/uploads/article/20180325/5ab7623c4558d.png\" alt=\"2018035_12\" title=\"2018035_12\"><br>git merge –no-ff 可以保存你之前的分支历史。能够更好的查看 merge历史，以及branch 状态。</p><p>git merge 则不会显示 feature，只保留单条分支记录。</p><h2>关于git pull -rebase和git pull</h2><p>这个问题的本质是变基和合并的选择，merge进行合并并提交之后，之前的所有提交将被丢弃，只保留merge的提交信息。而rebase变基的过程却是将分支的起点移动到了最新版本之后，保留了所有提交信息。如下。</p><pre><code class=\"lang-c\">rebase\n    A---B---C topic\n   /\n  D---E---F---G master\n  \n                A\'--B\'--C\' topic\n               /\n  D---E---F---G master</code></pre><pre><code class=\"lang-c\">merge\n     A---B---C topic\n    /\n   D---E---F---G master\n   \n    A-----B---C topic\n    /          \\\n    D---E---F---G---H master</code></pre><p>merge相当于把两个分支合并成一个新的分支，被合并的分支所有提交会丢失且变成一个merge提交合并到另一个分支（<strong>只需要解决一次冲突</strong>）。<br>rebase相等于从当前分支创建一个新的分支，再把另一个分支的提交记录一个个提交到新创建的分支。”优势是会保留所有的提交记录，劣势是两个分支差异太大的时候很要命（<strong>需要分别解决多次冲突</strong>）。</p><h4><a href=\"https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA\">变基和合并</a></h4><h4><a href=\"https://www.zhihu.com/question/36509119\">如何选择merge和rebase</a></h4><h4><a href=\"https://www.atlassian.com/git/tutorials/merging-vs-rebasing\">深入理解merge和rebase</a></h4><h2>关于git pull -rebase和git stash （save） && git stash pop/apply</h2><h4>先说一下pop和apply</h4><p>git stash apply，会将当前分支的最后一次缓存的内容释放出来，但是刚才的<strong>记录还存在list中</strong></p><p>git stash pop，也会将当前分支的最后一次缓存的内容释放出来，但是刚才的<strong>记录不存在list中</strong><br>ps： git stash clear清空stash</p><h4>再说一下怎么区分rebase和stash使用场景</h4><p><img src=\"/uploads/article/20180325/5ab758ed4c393.png\" alt=\"20180325_10\" title=\"20180325_10\"><br>这两个其实是比较好理解的，当在分支进行开发时，突然需要拉取新版代码，又不想放弃当前开发进度（废话），这时就有两个选择：</p><ol><li>将当前修改内容commit，然后使用git pull -rebase命令将本地commit内容连接到远处最新commit后。<strong>rebase 在拉代码前要确保你本地工作区是干净的，如果你本地修改的内容没完全 commit 或者 stash，就会 rebase 失败。</strong></li><li>不提交当前更改，使用git stash储藏改动的代码，使用git pull拉取后再git stash pop将储藏的改动取出。</li></ol>','查阅了很多资料，依然懵懵懂懂，先总结一下，之后补充。git pull = git fetch + git merge很好理解，fetch将代码拉取到本地暂存，merge再将本地暂存的代码合并到代码库 关于git pull rebase和git pull这个问题的本质是变基和合并的选择，merge进行合并并提交之后，之前的所有提交将被丢弃，只保留merge的提交信息。而rebase变...','git','/uploads/article/20180325/5ab7623c4558d.png',0,1,'2018-03-25 16:44:54','2018-03-25 16:48:55',NULL);
/*!40000 ALTER TABLE `bjy_articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_categories`
--

DROP TABLE IF EXISTS `bjy_categories`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_categories` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '分类主键id',
  `name` varchar(15) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '分类名称',
  `keywords` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '关键词',
  `description` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '描述',
  `sort` tinyint(1) NOT NULL DEFAULT '0' COMMENT '排序',
  `pid` tinyint(1) NOT NULL DEFAULT '0' COMMENT '父级栏目id',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_categories`
--

LOCK TABLES `bjy_categories` WRITE;
/*!40000 ALTER TABLE `bjy_categories` DISABLE KEYS */;
INSERT INTO `bjy_categories` VALUES (1,'PHP','php','php相关的文章',1,0,'2017-07-16 07:35:12','2018-03-15 19:58:02',NULL),(2,'笔试面试','笔试，面试','要开始准备招聘了，记录下遇到的知识点',3,0,'2018-03-15 19:56:59','2018-03-15 19:57:25',NULL),(3,'学习一个','小技巧,基本功','基本功',5,0,'2018-03-23 21:02:43','2018-03-23 21:02:43',NULL),(4,'收藏一个','收藏,好文','看到的好文章收藏一下',4,0,'2018-03-24 12:10:20','2018-03-24 12:10:20',NULL),(5,'Mysql','mysql,数据库','mysql相关',2,0,'2018-03-25 11:42:16','2018-03-25 11:42:16',NULL);
/*!40000 ALTER TABLE `bjy_categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_chats`
--

DROP TABLE IF EXISTS `bjy_chats`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_chats` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `content` text COLLATE utf8_unicode_ci NOT NULL COMMENT '内容',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_chats`
--

LOCK TABLES `bjy_chats` WRITE;
/*!40000 ALTER TABLE `bjy_chats` DISABLE KEYS */;
INSERT INTO `bjy_chats` VALUES (1,'技术这东西；懂的越多；不懂的就越多；','2017-07-18 07:35:12','2016-07-18 07:35:12',NULL),(2,'没时间扣代码的话就先睡个懒觉吧XD','2018-03-18 00:10:53','2018-03-18 20:38:44',NULL),(3,'伤人的话十句就够了','2018-03-18 22:18:27','2018-03-18 22:18:27',NULL),(4,'不上战场,就不会知道它的残酷','2018-03-21 10:29:20','2018-03-21 10:29:20',NULL),(5,'业精于勤而荒于嬉,行成于思而毁于随.与其临渊羡鱼,不如退而结网,积土为山,积水为海','2018-03-25 11:28:51','2018-03-25 11:28:51',NULL);
/*!40000 ALTER TABLE `bjy_chats` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_comments`
--

DROP TABLE IF EXISTS `bjy_comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_comments` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `oauth_user_id` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '评论用户id 关联oauth_user表的id',
  `type` tinyint(1) NOT NULL DEFAULT '1' COMMENT '1：文章评论',
  `pid` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '父级id',
  `article_id` int(10) unsigned NOT NULL COMMENT '文章id',
  `content` text COLLATE utf8_unicode_ci NOT NULL COMMENT '内容',
  `status` tinyint(1) NOT NULL COMMENT '1:已审核 0：未审核',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_comments`
--

LOCK TABLES `bjy_comments` WRITE;
/*!40000 ALTER TABLE `bjy_comments` DISABLE KEYS */;
INSERT INTO `bjy_comments` VALUES (1,1,1,0,1,'评论的内容',1,'2017-07-16 07:35:12','2016-07-16 07:35:12',NULL),(2,3,1,0,20,'[88]',1,'2018-03-22 21:12:11','2018-03-22 21:12:11',NULL);
/*!40000 ALTER TABLE `bjy_comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_configs`
--

DROP TABLE IF EXISTS `bjy_configs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_configs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '配置项键名',
  `value` text COLLATE utf8_unicode_ci COMMENT '配置项键值 1表示开启 0 关闭',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=54 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_configs`
--

LOCK TABLES `bjy_configs` WRITE;
/*!40000 ALTER TABLE `bjy_configs` DISABLE KEYS */;
INSERT INTO `bjy_configs` VALUES (1,'WEB_NAME','汤一碗博客','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(2,'WEB_KEYWORDS','个人博客,汤一碗,汤一碗博客','2017-04-25 12:12:00','2017-06-21 22:51:54',NULL),(3,'WEB_DESCRIPTION','个人博客,汤一碗,汤一碗博客','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(4,'WEB_STATUS','1','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(6,'WATER_TYPE','1','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(7,'TEXT_WATER_WORD','uliuli.fun','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(8,'TEXT_WATER_TTF_PTH','./Public/static/font/ariali.ttf','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(9,'TEXT_WATER_FONT_SIZE','15','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(10,'TEXT_WATER_COLOR','#008CBA','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(11,'TEXT_WATER_ANGLE','0','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(12,'TEXT_WATER_LOCATE','9','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(13,'IMAGE_WATER_PIC_PTAH','./Upload/image/logo/logo.png','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(14,'IMAGE_WATER_LOCATE','9','2017-04-25 12:12:00','2017-04-25 12:12:00',NULL),(15,'IMAGE_WATER_ALPHA','80','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(16,'WEB_CLOSE_WORD','网站升级中，请稍后访问。','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(17,'WEB_ICP_NUMBER','豫ICP备18006265号','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(18,'ADMIN_EMAIL','35151148@qq.com','2017-04-25 12:12:01','2017-06-21 22:51:54',NULL),(19,'COPYRIGHT_WORD','来自<a href=\"https://blog.uliuli.fun\">汤一碗博客','2017-04-25 12:12:01','2017-06-21 22:51:54',NULL),(20,'QQ_APP_ID','101459445','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(21,'CHANGYAN_APP_ID','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(22,'CHANGYAN_CONF','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(23,'WEB_STATISTICS','<script>\r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"https://hm.baidu.com/hm.js?27c3c8adafb16d2ed7cb5da91a1e6b80\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n</script>','2017-04-25 12:12:01','2017-06-21 22:51:54',NULL),(24,'CHANGEYAN_RETURN_COMMENT','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(25,'AUTHOR','汤一碗','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(26,'QQ_APP_KEY','902c666fc7bf99336621a54803f76012','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(27,'CHANGYAN_COMMENT','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(28,'BAIDU_SITE_URL','https://blog.uliuli.fun','2017-04-25 12:12:01','2017-06-21 22:51:54',NULL),(29,'DOUBAN_API_KEY','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(30,'DOUBAN_SECRET','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(31,'RENREN_API_KEY','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(32,'RENREN_SECRET','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(33,'SINA_API_KEY','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(34,'SINA_SECRET','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(35,'KAIXIN_API_KEY','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(36,'KAIXIN_SECRET','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(37,'SOHU_API_KEY','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(38,'SOHU_SECRET','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(39,'GITHUB_CLIENT_ID','f3836adff7af6296221d','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(40,'GITHUB_CLIENT_SECRET','1a63b822fe72bec9e46cd46beb02014886b837c6','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(41,'IMAGE_TITLE_ALT_WORD','汤一碗博客','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(42,'EMAIL_SMTP','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(43,'EMAIL_USERNAME','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(44,'EMAIL_PASSWORD','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(45,'EMAIL_FROM_NAME','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(46,'COMMENT_REVIEW','0','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(47,'COMMENT_SEND_EMAIL','1','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(48,'EMAIL_RECEIVE','','2017-04-25 12:12:01','2017-04-25 12:12:01',NULL),(49,'WEB_TITLE','汤一碗博客',NULL,NULL,NULL),(50,'QQ_QUN_ARTICLE_ID','',NULL,NULL,NULL),(51,'QQ_QUN_NUMBER','',NULL,NULL,NULL),(52,'QQ_QUN_CODE','<a target=\"_blank\" href=\"//shang.qq.com/wpa/qunwpa?idkey=08d6d612eb87f6c5cd0cf2cbf997ed5858a251ea5aefd38462d674977aa104d5\"><img border=\"0\" src=\"//pub.idqqimg.com/wpa/images/group.png\" alt=\"流云云流\" title=\"流云云流\"></a>',NULL,NULL,NULL),(53,'QQ_QUN_OR_CODE','/uploads/images/default.png',NULL,NULL,NULL);
/*!40000 ALTER TABLE `bjy_configs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_failed_jobs`
--

DROP TABLE IF EXISTS `bjy_failed_jobs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_failed_jobs` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `connection` text COLLATE utf8_unicode_ci NOT NULL,
  `queue` text COLLATE utf8_unicode_ci NOT NULL,
  `payload` longtext COLLATE utf8_unicode_ci NOT NULL,
  `exception` longtext COLLATE utf8_unicode_ci NOT NULL,
  `failed_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_failed_jobs`
--

LOCK TABLES `bjy_failed_jobs` WRITE;
/*!40000 ALTER TABLE `bjy_failed_jobs` DISABLE KEYS */;
/*!40000 ALTER TABLE `bjy_failed_jobs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_friendship_links`
--

DROP TABLE IF EXISTS `bjy_friendship_links`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_friendship_links` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `name` varchar(50) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '链接名',
  `url` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '链接地址',
  `sort` tinyint(1) DEFAULT '1' COMMENT '排序',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_friendship_links`
--

LOCK TABLES `bjy_friendship_links` WRITE;
/*!40000 ALTER TABLE `bjy_friendship_links` DISABLE KEYS */;
INSERT INTO `bjy_friendship_links` VALUES (1,'白俊遥博客','https://baijunyao.com',1,'2017-07-16 07:35:12','2016-07-16 07:35:12',NULL),(2,'老沙骑马的博客','https://qinyu2014.github.io',2,'2018-03-23 21:20:09','2018-03-23 21:21:50',NULL);
/*!40000 ALTER TABLE `bjy_friendship_links` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_git_projects`
--

DROP TABLE IF EXISTS `bjy_git_projects`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_git_projects` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '项目主键',
  `sort` tinyint(4) NOT NULL DEFAULT '1' COMMENT '排序',
  `type` tinyint(4) NOT NULL DEFAULT '1' COMMENT '1:github 2:gitee',
  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '项目名',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_git_projects`
--

LOCK TABLES `bjy_git_projects` WRITE;
/*!40000 ALTER TABLE `bjy_git_projects` DISABLE KEYS */;
INSERT INTO `bjy_git_projects` VALUES (1,1,1,'baijunyao/thinkphp-bjyadmin','2017-10-23 21:09:04','2018-03-15 19:53:41','2018-03-15 19:53:41'),(2,2,2,'shuaibai123/thinkphp-bjyadmin','2017-10-26 21:43:07','2018-03-15 19:53:43','2018-03-15 19:53:43'),(3,3,1,'baijunyao/thinkphp-bjyblog','2017-10-26 21:43:26','2018-03-15 19:53:45','2018-03-15 19:53:45'),(4,4,2,'shuaibai123/thinkbjy','2017-10-26 21:43:56','2018-03-15 19:53:39','2018-03-15 19:53:39'),(5,5,1,'baijunyao/laravel-bjyadmin','2017-10-26 22:03:15','2018-03-16 21:32:35',NULL),(6,6,1,'baijunyao/laravel-bjyblog','2017-10-26 22:03:23','2017-10-26 22:03:23',NULL),(7,7,2,'shuaibai123/laravel-bjyadmin','2017-10-26 22:07:24','2018-03-15 19:53:31','2018-03-15 19:53:31'),(8,8,2,'shuaibai123/laravel-bjyblog','2017-10-26 22:07:47','2018-03-15 19:53:33','2018-03-15 19:53:33');
/*!40000 ALTER TABLE `bjy_git_projects` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_jobs`
--

DROP TABLE IF EXISTS `bjy_jobs`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_jobs` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `queue` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `payload` longtext COLLATE utf8_unicode_ci NOT NULL,
  `attempts` tinyint(3) unsigned NOT NULL,
  `reserved_at` int(10) unsigned DEFAULT NULL,
  `available_at` int(10) unsigned NOT NULL,
  `created_at` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`),
  KEY `jobs_queue_reserved_at_index` (`queue`,`reserved_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_jobs`
--

LOCK TABLES `bjy_jobs` WRITE;
/*!40000 ALTER TABLE `bjy_jobs` DISABLE KEYS */;
/*!40000 ALTER TABLE `bjy_jobs` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_migrations`
--

DROP TABLE IF EXISTS `bjy_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_migrations` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `migration` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `batch` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_migrations`
--

LOCK TABLES `bjy_migrations` WRITE;
/*!40000 ALTER TABLE `bjy_migrations` DISABLE KEYS */;
INSERT INTO `bjy_migrations` VALUES (1,'2014_10_12_000000_create_users_table',1),(2,'2014_10_12_100000_create_password_resets_table',1),(3,'2017_07_11_225347_create_article_tags_table',1),(4,'2017_07_11_225347_create_articles_table',1),(5,'2017_07_11_225347_create_categories_table',1),(6,'2017_07_11_225347_create_chats_table',1),(7,'2017_07_11_225347_create_comments_table',1),(8,'2017_07_11_225347_create_configs_table',1),(9,'2017_07_11_225347_create_friendship_links_table',1),(10,'2017_07_11_225347_create_oauth_users_table',1),(11,'2017_07_11_225347_create_tags_table',1),(12,'2017_08_26_211441_create_jobs_table',1),(13,'2017_08_26_212556_create_failed_jobs_table',1),(14,'2017_10_18_203752_create_git_projects_table',1);
/*!40000 ALTER TABLE `bjy_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_oauth_users`
--

DROP TABLE IF EXISTS `bjy_oauth_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_oauth_users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `type` tinyint(1) NOT NULL DEFAULT '1' COMMENT '类型 1：QQ  2：新浪微博 3：github',
  `name` varchar(30) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '第三方昵称',
  `avatar` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '头像',
  `openid` varchar(40) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '第三方用户id',
  `access_token` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT 'access_token token',
  `last_login_ip` varchar(16) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '最后登录ip',
  `login_times` int(10) unsigned NOT NULL DEFAULT '0' COMMENT '登录次数',
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '邮箱',
  `is_admin` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否是admin',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_oauth_users`
--

LOCK TABLES `bjy_oauth_users` WRITE;
/*!40000 ALTER TABLE `bjy_oauth_users` DISABLE KEYS */;
INSERT INTO `bjy_oauth_users` VALUES (1,1,'白俊遥','/uploads/article/default.jpg','','','127.0.0.1',1,'baijunyao@baijunyao.com',0,'2017-07-24 07:35:12','2017-07-24 07:35:12',NULL),(2,3,'tangmingshuai','/uploads/avatar/2.jpg','16934582','5ec005f7ed237bd078ad50832a1b579759a98ebc','172.17.0.2',8,'',1,'2018-03-16 21:49:33','2018-03-22 21:15:30',NULL),(3,1,'(ˇˍˇ）～','/uploads/avatar/3.jpg','5D283D2961885E520DE8EB07669C290D','E0BA24821F644DC3E36A7A2413BF7B3C','172.17.0.2',1,'',1,'2018-03-22 21:11:47','2018-03-22 21:16:07',NULL);
/*!40000 ALTER TABLE `bjy_oauth_users` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_password_resets`
--

DROP TABLE IF EXISTS `bjy_password_resets`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_password_resets` (
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `token` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  KEY `password_resets_email_index` (`email`),
  KEY `password_resets_token_index` (`token`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_password_resets`
--

LOCK TABLES `bjy_password_resets` WRITE;
/*!40000 ALTER TABLE `bjy_password_resets` DISABLE KEYS */;
/*!40000 ALTER TABLE `bjy_password_resets` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_tags`
--

DROP TABLE IF EXISTS `bjy_tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_tags` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT COMMENT '标签主键',
  `name` varchar(10) COLLATE utf8_unicode_ci NOT NULL DEFAULT '' COMMENT '标签名',
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_tags`
--

LOCK TABLES `bjy_tags` WRITE;
/*!40000 ALTER TABLE `bjy_tags` DISABLE KEYS */;
INSERT INTO `bjy_tags` VALUES (1,'laravel','2017-07-16 07:35:12','2016-07-16 07:35:12',NULL),(2,'面试','2018-03-15 19:59:28','2018-03-15 19:59:28',NULL),(3,'笔试','2018-03-15 19:59:32','2018-03-15 19:59:32',NULL),(4,'linux','2018-03-15 19:59:47','2018-03-15 19:59:47',NULL),(5,'操作系统','2018-03-15 19:59:52','2018-03-15 19:59:52',NULL),(6,'运维','2018-03-15 19:59:58','2018-03-15 19:59:58',NULL),(7,'测试','2018-03-17 00:12:28','2018-03-17 00:12:28',NULL),(8,'智力题','2018-03-17 00:25:00','2018-03-17 00:25:00',NULL),(9,'算法','2018-03-17 00:41:31','2018-03-17 00:41:31',NULL),(10,'计算机网络','2018-03-18 23:01:19','2018-03-18 23:01:19',NULL),(11,'数据库','2018-03-19 00:13:42','2018-03-19 00:13:42',NULL),(12,'小技巧','2018-03-22 23:22:17','2018-03-22 23:22:17',NULL),(13,'PHP','2018-03-23 20:37:40','2018-03-23 20:37:40',NULL),(14,'安全','2018-03-24 12:55:41','2018-03-24 12:55:41',NULL);
/*!40000 ALTER TABLE `bjy_tags` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `bjy_users`
--

DROP TABLE IF EXISTS `bjy_users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bjy_users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `email` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `password` varchar(255) COLLATE utf8_unicode_ci NOT NULL,
  `remember_token` varchar(100) COLLATE utf8_unicode_ci DEFAULT NULL,
  `created_at` timestamp NULL DEFAULT NULL,
  `updated_at` timestamp NULL DEFAULT NULL,
  `deleted_at` timestamp NULL DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `users_email_unique` (`email`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bjy_users`
--

LOCK TABLES `bjy_users` WRITE;
/*!40000 ALTER TABLE `bjy_users` DISABLE KEYS */;
INSERT INTO `bjy_users` VALUES (1,'一碗','35151148@qq.com','$2y$10$IrfezlW617OMCEoApcf1OuK9LmUrcyGgjO40n941yk4iA0vbLNnOa','zhVCdF5yglpVdW8lBWsyadftLOXiYRfHTHXGwN1PgUM11CboWQLwx4TYdzon','2016-10-22 07:35:12','2018-03-15 19:52:48',NULL);
/*!40000 ALTER TABLE `bjy_users` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2018-03-25 18:26:43
